# -*- mode: Conf; -*-
# https://releases.llvm.org/14.0.0/tools/clang/docs/ClangFormat.html
# https://releases.llvm.org/14.0.0/tools/clang/docs/ClangFormatStyleOptions.html

---
Language: Cpp

# base is WebKit coding style: https://webkit.org/code-style-guidelines/
# below are only things set that diverge from this style!
# BasedOnStyle: WebKit

# The extra indent or outdent of access modifiers, e.g. public:.
AccessModifierOffset: -2

# If true, horizontally aligns arguments after an open bracket.
AlignAfterOpenBracket: Align
# if not None, when using initialization for an array of structs aligns the fields into columns.
# AlignArrayOfStructures: Right
# Style of aligning consecutive assignments.
AlignConsecutiveAssignments: None
# Style of aligning consecutive bit fields.
AlignConsecutiveBitFields: Consecutive
# Style of aligning consecutive declarations.
AlignConsecutiveDeclarations: None
# Style of aligning consecutive macro definitions.
AlignConsecutiveMacros: None
# Options for aligning backslashes in escaped newlines.
#   Left ?
AlignEscapedNewlines: Right
# If true, horizontally align operands of binary and ternary expressions.
#   AlignAfterOperator ?
AlignOperands: Align
# if true, aligns trailing comments.
AlignTrailingComments: true

# If a function call or braced initializer list doesn’t fit on a line,
# allow putting all arguments onto the next line, even if BinPackArguments is false.
AllowAllArgumentsOnNextLine: false
## This option is deprecated. See NextLine of PackConstructorInitializers.
##d AllowAllConstructorInitializersOnNextLine: false
# if the function declaration doesn’t fit on a line,
# allow putting all parameters of a function declaration onto the next line even if BinPackParameters is false.
AllowAllParametersOfDeclarationOnNextLine: false

# Dependent on the value, while (true) { continue; } can be put on a single line.
#  Empty Never Always
AllowShortBlocksOnASingleLine: Empty
# If true, short case labels will be contracted to a single line.
AllowShortCaseLabelsOnASingleLine: false
# Allow short enums on a single line.
#   false because not so short
AllowShortEnumsOnASingleLine: false
# Dependent on the value, int f() { return 0; } can be put on a single line.
# InlineOnly
AllowShortFunctionsOnASingleLine: InlineOnly
# Dependent on the value, if (a) return; can be put on a single line.
AllowShortIfStatementsOnASingleLine: Never
# Dependent on the value, auto lambda []() { return 0; } can be put on a single line.
AllowShortLambdasOnASingleLine: All
# If true, while (true) continue; can be put on a single line.
AllowShortLoopsOnASingleLine: false

## The function definition return type breaking style to use.
## This option is deprecated and is retained for backwards compatibility.
##d AlwaysBreakAfterDefinitionReturnType: true
# The function declaration return type breaking style to use.
AlwaysBreakAfterReturnType: TopLevelDefinitions
# If true, always break before multiline string literals.
AlwaysBreakBeforeMultilineStrings: false
# The template declaration breaking style to use.
AlwaysBreakTemplateDeclarations: MultiLine

# A vector of strings that should be interpreted as attributes/qualifiers instead of identifiers.
# This can be useful for language extensions or static analyzer annotations.
AttributeMacros:
  - __capability

# don't move arguments to own lines if they are not all on the same
BinPackArguments: false
# If false, a function declaration’s or function definition’s parameters will either all be on the same line or will have one line each.
BinPackParameters: false

# The BitFieldColonSpacingStyle to use for bitfields.
BitFieldColonSpacing: Both

# Control of individual brace wrapping cases.
# If BreakBeforeBraces is set to Custom, use this to specify how each individual brace case should be handled. Otherwise, this is ignored.
BraceWrapping:
  AfterCaseLabel:        false
  AfterClass:            true
  AfterControlStatement: Never
  AfterEnum:             false
  AfterFunction:         true
  AfterNamespace:        false
  AfterStruct:           true
  AfterUnion:            false
  AfterExternBlock:      false
  BeforeCatch:           false
  BeforeElse:            false
  BeforeLambdaBody:      false
  BeforeWhile:           false
  # Indent the wrapped braces themselves.
  IndentBraces:          false
  # If false, empty function body can be put on a single line.
  SplitEmptyFunction:    false
  # If false, empty record (e.g. class, struct or union) body can be put on a single line.
  SplitEmptyRecord:      false
  # If false, empty namespace body can be put on a single line.
  SplitEmptyNamespace:   false
  ## AfterObjCDeclaration : false

# The way to wrap binary operators.
# None NonAssignment All
BreakBeforeBinaryOperators: All
# The brace breaking style to use.
# Linux: Like Attach, but break before braces on function, namespace and class definitions.
BreakBeforeBraces: Custom
# The concept declaration style to use.
BreakBeforeConceptDeclarations: true
BreakBeforeInheritanceComma: false
# If true, ternary operators will be placed after line breaks.
BreakBeforeTernaryOperators: true
# The break constructor initializers style to use.
# BeforeColon BeforeComma AfterColon
BreakConstructorInitializers: BeforeComma
BreakConstructorInitializersBeforeComma: true
# The inheritance list style to use.
BreakInheritanceList: BeforeColon
# Allow breaking string literals when formatting.
BreakStringLiterals: true

# The column limit.
# A column limit of 0 means that there is no column limit. In this case, clang-format will respect
# the input’s line breaking decisions within statements unless they contradict other rules.
# ColumnLimit: 160
ColumnLimit: 0

# A regular expression that describes comments with special meaning, which should not be split into lines or otherwise change
CommentPragmas: '^ IWYU pragma:'

# If true, consecutive namespace declarations will be on the same line. If false, each namespace is declared on a new line.
CompactNamespaces: false

## This option is deprecated. See CurrentLine of PackConstructorInitializers.
##d ConstructorInitializerAllOnOneLineOrOnePerLine: true
# The number of characters to use for indentation of constructor initializer lists as well as inheritance lists.
ConstructorInitializerIndentWidth: 2

# Indent width for line continuations.
ContinuationIndentWidth: 2

# If true, format braced lists as best suited for C++11 braced lists.
Cpp11BracedListStyle: true

# Analyze the formatted file for the most used line ending (\r\n or \n). UseCRLF is only used as a fallback if none can be derived.
DeriveLineEnding: false
# If true, analyze the formatted file for the most common alignment of & and *. Pointer
# and reference alignment styles are going to be updated according to the preferences found in the file.
# PointerAlignment is then used only as fallback.
DerivePointerAlignment: false

# Disables formatting completely.
DisableFormat: false

# Defines when to put an empty line after access modifiers.
# EmptyLineBeforeAccessModifier configuration handles the number of empty lines between two access modifiers.
EmptyLineAfterAccessModifier: Never
# Defines in which cases to put empty line before access modifiers.
EmptyLineBeforeAccessModifier: LogicalBlock

# If true, clang-format detects whether function calls and definitions are formatted with one parameter per line.
ExperimentalAutoDetectBinPacking: true

# If true, clang-format adds missing namespace end comments for short namespaces and fixes invalid existing ones.
# Short ones are controlled by “ShortNamespaceLines”.
FixNamespaceComments: true

# A vector of macros that should be interpreted as foreach loops instead of as function calls.
ForEachMacros:
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH

# A vector of macros that should be interpreted as conditionals instead of as function calls.
# IfMacros:

# Dependent on the value, multiple #include blocks can be sorted as one and divided based on category.
IncludeBlocks: Preserve

# Regular expressions denoting the different #include categories used for ordering #includes.
IncludeCategories:
  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    Priority:        2
    SortPriority:    0
    CaseSensitive:   false
  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    Priority:        3
    SortPriority:    0
    CaseSensitive:   false
  - Regex:           '.*'
    Priority:        1
    SortPriority:    0
    CaseSensitive:   false

# Specify a regular expression of suffixes that are allowed in the file-to-main-include mapping.
IncludeIsMainRegex: '(Test)?$'
# Specify a regular expression for files being formatted that are allowed to be considered “main” in the file-to-main-include mapping.
IncludeIsMainSourceRegex: ''

# Specify whether access modifiers should have their own indentation level.
# IndentAccessModifiers: false
# Indent case label blocks one level from the case label.
IndentCaseBlocks: false
# Indent case labels one level from the switch statement.
IndentCaseLabels: false
# IndentExternBlockStyle is the type of indenting of extern blocks.
IndentExternBlock: AfterExternBlock
# Indent goto labels.
IndentGotoLabels: true
# The preprocessor directive indenting style to use.
IndentPPDirectives: None
# Indent the requires clause in a template. This only applies when RequiresClausePosition is OwnLine, or WithFollowing.
IndentRequires: false
# The number of columns to use for indentation.
IndentWidth: 2
# Indent if a function definition or declaration is wrapped after the type.
IndentWrappedFunctionNames: false

# Insert braces after control statements (if, else, for, do, and while) in C++
# unless the control statements are inside macro definitions or the braces would enclose preprocessor directives.
#N15 InsertBraces: false
# If set to TCS_Wrapped will insert trailing commas in container literals (arrays and objects) that wrap across multiple lines.
# It is currently only available for JavaScript and disabled by default TCS_None.
# InsertTrailingCommas cannot be used together with BinPackArguments as inserting the comma disables bin-packing.
InsertTrailingCommas: None

# If true, the empty line at the start of blocks is kept.
KeepEmptyLinesAtTheStartOfBlocks: false

# The indentation style of lambda bodies. Signature (the default) causes the lambda body to be
# indented one additional level relative to the indentation level of the signature. OuterScope
# forces the lambda body to be indented one additional level relative to the parent scope containing
# the lambda signature. For callback-heavy code, it may improve readability to have the signature
# indented two levels and to use OuterScope. The KJ style guide requires OuterScope
# LambdaBodyIndentation: Signature

# A regular expression matching macros that start a block.
MacroBlockBegin: ''
# A regular expression matching macros that end a block.
MacroBlockEnd:   ''

# The maximum number of consecutive empty lines to keep.
MaxEmptyLinesToKeep: 1

# The indentation used for namespaces.
NamespaceIndentation: None

# A vector of macros which are used to open namespace blocks.
# NamespaceMacros:

# ObjCBinPackProtocolList: Auto
# ObjCBlockIndentWidth: 2
# ObjCBreakBeforeNestedBlockParam: true
# ObjCSpaceAfterProperty: false
# ObjCSpaceBeforeProtocolList: true

# The number of columns to use for indentation of preprocessor statements.
# When set to -1 (default) IndentWidth is used also for preprocessor statements.
# PPIndentWidth: 2

# The pack constructor initializers style to use.
PackConstructorInitializers: Never

# The penalty for breaking around an assignment operator.
PenaltyBreakAssignment: 2
# The penalty for breaking a function call after call(.
PenaltyBreakBeforeFirstCallParameter: 19
# The penalty for each line break introduced inside a comment.
PenaltyBreakComment: 300
# The penalty for breaking before the first <<.
PenaltyBreakFirstLessLess: 120
# The penalty for breaking after (.
# PenaltyBreakOpenParenthesis: 0
# The penalty for each line break introduced inside a string literal.
PenaltyBreakString: 1000
# The penalty for breaking after template declaration.
PenaltyBreakTemplateDeclaration: 10
# The penalty for each character outside of the column limit.
PenaltyExcessCharacter: 1000000
# Penalty for each character of whitespace indentation (counted relative to leading non-whitespace column).
PenaltyIndentedWhitespace: 0
# Penalty for putting the return type of a function onto its own line.
PenaltyReturnTypeOnItsOwnLine: 60

# Pointer and reference alignment style.
PointerAlignment: Middle

# Different ways to arrange specifiers and qualifiers (e.g. const/volatile).
# QualifierAlignment: Left
# The order in which the qualifiers appear. Order is an array that can contain any of the following:
#N15 QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]

# Defines hints for detecting supported languages code blocks in raw strings.
# RawStringFormats:

# Reference alignment style (overrides PointerAlignment for references).
ReferenceAlignment: Middle

# If true, clang-format will attempt to re-flow comments.
ReflowComments: false

# Remove optional braces of control statements (if, else, for, and while) in C++ according to the LLVM coding style.
#N15 RemoveBracesLLVM: true

# The position of the requires clause.
# RequiresClausePosition:

# Specifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions.
#N15 SeparateDefinitionBlocks: Always

# The maximal number of unwrapped lines that a short namespace spans. Defaults to 1.
ShortNamespaceLines: 1

# Controls if and how clang-format will sort #includes.
# If Never, includes are never sorted. If CaseInsensitive, includes are sorted in an ASCIIbetical or case insensitive fashion.
# If CaseSensitive, includes are sorted in an alphabetical or case sensitive fashion.
SortIncludes: true # CaseInsensitive
# If true, clang-format will sort using declarations.
SortUsingDeclarations: true

# If true, a space is inserted after C style casts.
SpaceAfterCStyleCast: false
# If true, a space is inserted after the logical not operator (!).
SpaceAfterLogicalNot: false
# If true, a space will be inserted after the ‘template’ keyword.
SpaceAfterTemplateKeyword: true
# Defines in which cases to put a space before or after pointer qualifiers
SpaceAroundPointerQualifiers: Default
# If false, spaces will be removed before assignment operators.
SpaceBeforeAssignmentOperators: true
# If false, spaces will be removed before case colon.
SpaceBeforeCaseColon: false
# If true, a space will be inserted before a C++11 braced list used to initialize an object (after the preceding identifier or type).
SpaceBeforeCpp11BracedList: false
# If false, spaces will be removed before constructor initializer colon.
SpaceBeforeCtorInitializerColon: true
# If false, spaces will be removed before inheritance colon.
SpaceBeforeInheritanceColon: true
# Defines in which cases to put a space before opening parentheses.
SpaceBeforeParens: ControlStatements
# Control of individual space before parentheses.
# SpaceBeforeParensOptions:
# If false, spaces will be removed before range-based for loop colon.
SpaceBeforeRangeBasedForLoopColon: true
# If true, spaces will be before [. Lambdas will not be affected. Only the first [ will get a space added.
SpaceBeforeSquareBrackets: false
# If true, spaces will be inserted into {}.
SpaceInEmptyBlock: false
# If true, spaces may be inserted into ().
SpaceInEmptyParentheses: false
# The number of spaces before trailing line comments (// - comments).
SpacesBeforeTrailingComments: 1
# The SpacesInAnglesStyle to use for template argument lists.
SpacesInAngles: false
# If true, spaces may be inserted into C style casts.
SpacesInCStyleCastParentheses: false
# If true, spaces will be inserted around if/for/switch/while conditions.
SpacesInConditionalStatement: false
# If true, spaces are inserted inside container literals (e.g. ObjC and Javascript array and dict literals).
SpacesInContainerLiterals: true
# How many spaces are allowed at the start of a line comment.
# To disable the maximum set it to -1, apart from that the maximum takes precedence over the minimum.
# SpacesInLineCommentPrefix:
# If true, spaces will be inserted after ( and before ).
SpacesInParentheses: false
# If true, spaces will be inserted after [ and before ]. Lambdas without arguments or unspecified size array declarations will not be affected.
SpacesInSquareBrackets: false

# Parse and format C++ constructs compatible with this standard.
Standard: Latest

# Macros which are ignored in front of a statement, as if they were an attribute.
# So that they are not parsed as identifier, for example for Qts emit.
StatementAttributeLikeMacros:
  - Q_EMIT

# A vector of macros that should be interpreted as complete statements.
StatementMacros:
  - Q_UNUSED
  - QT_REQUIRE_VERSION

# The number of columns used for tab stops.
TabWidth: 8

# Use \r\n instead of \n for line breaks. Also used as fallback if DeriveLineEnding is true.
UseCRLF: false

# The way to use tab characters in the resulting file.
UseTab: Never

# A vector of macros which are whitespace-sensitive and should not be touched.
WhitespaceSensitiveMacros:
  - STRINGIZE
  - PP_STRINGIZE
  - BOOST_PP_STRINGIZE
  - NS_SWIFT_NAME
  - CF_SWIFT_NAME

---
Language: Java
SortJavaStaticImport: Before

# Break after each annotation on a field in Java files.
BreakAfterJavaFieldAnnotations: false

# A vector of prefixes ordered by the desired groups for Java imports.
# JavaImportGroups:
# The JavaScriptQuoteStyle to use for JavaScript strings.
JavaScriptQuotes: Leave
# Whether to wrap JavaScript import/export statements.
JavaScriptWrapImports: true

# When sorting Java imports, by default static imports are placed before non-static imports.
# If JavaStaticImportAfterImport is After, static imports are placed after non-static imports.
# SortJavaStaticImport:

---
Language: JavaScript
DisableFormat: true
