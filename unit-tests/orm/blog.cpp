// This file was automatically generated by SqlOrm

/***************************************************************************************************
 *
 * $ALPINE_TOOLKIT_BEGIN_LICENSE:GPL3$
 *
 * Copyright (C) 2017 Fabrice Salvaire
 * Contact: http://www.fabrice-salvaire.fr
 *
 * This file is part of the Alpine Toolkit software.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * $ALPINE_TOOLKIT_END_LICENSE$
 *
 **************************************************************************************************/

/**************************************************************************************************/

#include "blog.h"
#include "alpine_toolkit.h"

#include "orm/database_query.h"
#include "orm/type_conversion.h"

#include <QtDebug>

/**************************************************************************************************/

// QC_BEGIN_NAMESPACE


AuthorSchema::AuthorSchema()
: QoSchema(QLatin1String("Author"), QLatin1String("authors"))
{
  {
    QoSchemaPrimaryKey field(
      QLatin1String("id"),
      QLatin1String("int"),
      QLatin1String("integer"),
      QLatin1String("id"),
      QLatin1String("id"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    field.set_nullable(false);
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("name"),
      QLatin1String("QString"),
      QLatin1String("text"),
      QLatin1String("name"),
      QLatin1String("name"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("birthdate"),
      QLatin1String("QDateTime"),
      QLatin1String("text"),
      QLatin1String("birthdate"),
      QLatin1String("birthdate"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
}

AuthorSchema::~AuthorSchema()
{}

/**************************************************************************************************/

Author::Author()
  : QObject(),
    QoRow<AuthorSchema>(),
    m_id(),
    m_name(),
    m_birthdate()
{
}

Author::Author(const Author & other)
  : QObject(),
    QoRow<AuthorSchema>(other),
    m_id(other.m_id),
    m_name(other.m_name),
    m_birthdate(other.m_birthdate)
{
}

Author::Author(const QJsonObject & json_object)
 : Author()
{
  m_id = json_object[QLatin1String("id")].toInt();
  m_name = json_object[QLatin1String("name")].toString();
  m_birthdate = orm_type_conversion::load_datetime(json_object[QLatin1String("birthdate")]);
}

Author::Author(const QVariantHash & variant_hash)
 : Author()
{
  m_id = variant_hash[QLatin1String("id")].toInt();
  m_name = variant_hash[QLatin1String("name")].toString();
  m_birthdate = variant_hash[QLatin1String("birthdate")].toDateTime();
}

Author::Author(const QVariantList & variants)
 : Author()
{
  m_id = variants[0].toInt();
  m_name = variants[1].toString();
  m_birthdate = variants[2].toDateTime();
}

Author::Author(const QSqlRecord & record)
 : QoRow<AuthorSchema>(record)
{
  m_id = record.value(0).toInt();
  m_name = record.value(1).toString();
  m_birthdate = record.value(2).toDateTime();
}

Author::Author(const QSqlQuery & query, int offset)
 : QoRow<AuthorSchema>(query)
{
  m_id = query.value(offset++).toInt();
  m_name = query.value(offset++).toString();
  m_birthdate = query.value(offset).toDateTime();
}

Author::~Author()
{
// qATInfo() << "--- Delete" << "Author" << *this;
}

// bit array ?
Author &
Author::operator=(const Author & other)
{
  if (this != &other) {
    QoRow<AuthorSchema>::operator=(other);
    m_id = other.m_id;
    m_name = other.m_name;
    m_birthdate = other.m_birthdate;
  }

  return *this;
}

// bit array ?
bool
Author::operator==(const Author & other) const
{
  if (not QoRow<AuthorSchema>::operator==(other))
    return false;
  if (m_id != other.m_id)
    return false;
  if (m_name != other.m_name)
    return false;
  if (m_birthdate != other.m_birthdate)
    return false;

  return true;
}

void
Author::set_id(int value)
{
  if (m_id != value) {
    m_id = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::ID);

    emit idChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Author::set_name(const QString & value)
{
  if (m_name != value) {
    m_name = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::NAME);

    emit nameChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Author::set_birthdate(const QDateTime & value)
{
  if (m_birthdate != value) {
    m_birthdate = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::BIRTHDATE);

    emit birthdateChanged();
    if (not is_changed)
      emit changed();
  }
}

QJsonObject
Author::to_json(bool only_changed) const
{
  QJsonObject json_object;

 if (only_changed) {
    if (is_id_modified())
      json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    if (is_name_modified())
      json_object.insert(QLatin1String("name"), QJsonValue(m_name));
    if (is_birthdate_modified())
      json_object.insert(QLatin1String("birthdate"), orm_type_conversion::dump_datetime(m_birthdate));
  } else {
    json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    json_object.insert(QLatin1String("name"), QJsonValue(m_name));
    json_object.insert(QLatin1String("birthdate"), orm_type_conversion::dump_datetime(m_birthdate));
  }

  return json_object;
}

QVariantHash
Author::to_variant_hash(bool only_changed) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_name_modified())
      variant_hash[QLatin1String("name")] = m_name;
    if (is_birthdate_modified())
      variant_hash[QLatin1String("birthdate")] = m_birthdate;
  } else {
    variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("name")] = m_name;
    variant_hash[QLatin1String("birthdate")] = m_birthdate;
  }

  return variant_hash;
}

QVariantList
Author::to_variant_list() const
{
  QVariantList variants;

  variants << m_id;
  variants << m_name;
  variants << m_birthdate;

  return variants;
}

QVariantHash
Author::to_variant_hash_sql(bool only_changed, bool duplicate) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_name_modified())
      variant_hash[QLatin1String("name")] = m_name;
    if (is_birthdate_modified())
      variant_hash[QLatin1String("birthdate")] = m_birthdate;
  } else {
    if (duplicate)
      variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("name")] = m_name;
    variant_hash[QLatin1String("birthdate")] = m_birthdate;
  }

  return variant_hash;
}

QVariantList
Author::to_variant_list_sql(bool duplicate) const
{
  QVariantList variants;

  if (duplicate)
    variants << m_id;
  variants << m_name;
  variants << m_birthdate;

  return variants;
}

QVariant
Author::field(int position) const
{
  switch(position) {
   case Schema::Fields::ID:
     return m_id;
   case Schema::Fields::NAME:
     return m_name;
   case Schema::Fields::BIRTHDATE:
     return m_birthdate;
   default:
     return QVariant(); // error
  }
}

void
Author::set_field(int position, const QVariant & value)
{
  switch(position) {
   case Schema::Fields::ID: {
     m_id = value.toInt();
     break;
   }
   case Schema::Fields::NAME: {
     m_name = value.toString();
     break;
   }
   case Schema::Fields::BIRTHDATE: {
     m_birthdate = value.toDateTime();
     break;
   }
  }
}

void
Author::set_insert_id(int id)
{
  set_id(id);

  for (const auto & item_weak_ref : m_blogs)
    item_weak_ref.data()->set_author_id(id); // Fixme: check ref
}

void
Author::load_relations()
{
  qATInfo() << "Load relations of" << *this;
  {
    // Load one-to-many relation blogs
    Blog::PtrList rows = database_schema()->query_by_foreign_key<Blog>(
      QLatin1String("author_id"),
      m_id); // true
    m_blogs = rows;
  }
}

void
Author::save_relations()
{
  qATInfo() << "Save relations of" << *this;
  for (const auto & item_weak_ref : m_blogs) {
    Blog * item_ptr = item_weak_ref.data();
    if (not item_ptr->exists_on_database())
      database_schema()->add(*item_ptr);
  }
}

bool
Author::can_update() const
{
  return m_id > 0;
}

QVariantHash
Author::rowid_kwargs() const // To update row
{
  QVariantHash where_kwargs;
  where_kwargs[QLatin1String("id")] = m_id;
  return where_kwargs;
}

QDataStream &
operator<<(QDataStream & out, const Author & obj)
{
  out << obj.id();
  out << obj.name();
  out << obj.birthdate();

  return out;
}

QDataStream &
operator>>(QDataStream & in, Author & obj)
{
  QDateTime _QDateTime;
  QString _QString;
  int _int;
  in >> _int;
  obj.set_id(_int);
  in >> _QString;
  obj.set_name(_QString);
  in >> _QDateTime;
  obj.set_birthdate(_QDateTime);

  return in;
}

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const Author & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  // Fixme: quote string !
  debug.nospace() << QLatin1Literal("Author(");
  debug << obj.id();
  debug << QLatin1Literal(", ");
  debug << obj.name();
  debug << QLatin1Literal(", ");
  debug << obj.birthdate();
  debug << ')';

  return debug;
}
#endif

/**************************************************************************************************/

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const AuthorPtr & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  debug.noquote() << QLatin1Literal("AuthorPtr ->");
  if (obj)
    debug << *obj;
   else
  debug  << QLatin1Literal("NULL");

  return debug;
}
#endif

/**************************************************************************************************/

AuthorCache::AuthorCache()
 : m_loaded_instances(),
   m_modified_instances()
{}

AuthorCache::~AuthorCache()
{}

void
AuthorCache::add(AuthorPtr & ptr)
{
  m_loaded_instances.insert(ptr.data(), ptr);
  QObject::connect(ptr.data(), &Author::changed,
                   this, &AuthorCache::on_changed);
}

void
AuthorCache::remove(AuthorPtr & ptr)
{
  Q_UNUSED(ptr);
}

void
AuthorCache::on_changed()
{
  Author * row = qobject_cast<Author *>(QObject::sender());
  qATInfo() << "On changed" << row;
  AuthorPtr row_ptr = m_loaded_instances[row];
  if (row_ptr)
    m_modified_instances.insert(row, row_ptr);
}

/**************************************************************************************************/

AuthorModel::AuthorModel()
  : QAbstractListModel(),
    m_items()
{}

AuthorModel::AuthorModel(const ItemList & items)
  : QAbstractListModel(),
    m_items(items)
{}

AuthorModel::~AuthorModel()
{}

int
AuthorModel::rowCount(const QModelIndex & parent) const
{
  Q_UNUSED(parent);
  return m_items.size();
}

QVariant
AuthorModel::data(const QModelIndex & index, int role) const
{
  if (!index.isValid() || index.row() < 0)
    return QVariant();

  if (index.row() >= m_items.count()) {
    qWarning() << "AuthorModel: Index out of bound";
    return QVariant();
  }

  const Item & item = m_items[index.row()];
  switch (role) {
  case ID:
    return item->id();
  case NAME:
    return item->name();
  case BIRTHDATE:
    return item->birthdate();
  default:
    break;
  }

  return QVariant();
}

QHash<int, QByteArray>
AuthorModel::roleNames() const
{
  // Fixme: cache ???
  QHash<int, QByteArray> role_names;
  role_names[ID] = QLatin1Literal("id").latin1();
  role_names[NAME] = QLatin1Literal("name").latin1();
  role_names[BIRTHDATE] = QLatin1Literal("birthdate").latin1();

  return role_names;
}

void
AuthorModel::clear_items()
{
  beginResetModel();
  m_items.clear();
  endResetModel();
}

void
AuthorModel::set_items(const ItemList & items)
{
  beginResetModel();
  m_items = items;
  endResetModel();
}

CategorySchema::CategorySchema()
: QoSchema(QLatin1String("Category"), QLatin1String("categories"))
{
  {
    QoSchemaPrimaryKey field(
      QLatin1String("id"),
      QLatin1String("int"),
      QLatin1String("integer"),
      QLatin1String("id"),
      QLatin1String("id"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    field.set_nullable(false);
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("name"),
      QLatin1String("QString"),
      QLatin1String("text"),
      QLatin1String("name"),
      QLatin1String("name"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("description"),
      QLatin1String("QString"),
      QLatin1String("text"),
      QLatin1String("description"),
      QLatin1String("description"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
}

CategorySchema::~CategorySchema()
{}

/**************************************************************************************************/

Category::Category()
  : QObject(),
    QoRow<CategorySchema>(),
    m_id(),
    m_name(),
    m_description()
{
}

Category::Category(const Category & other)
  : QObject(),
    QoRow<CategorySchema>(other),
    m_id(other.m_id),
    m_name(other.m_name),
    m_description(other.m_description)
{
}

Category::Category(const QJsonObject & json_object)
 : Category()
{
  m_id = json_object[QLatin1String("id")].toInt();
  m_name = json_object[QLatin1String("name")].toString();
  m_description = json_object[QLatin1String("description")].toString();
}

Category::Category(const QVariantHash & variant_hash)
 : Category()
{
  m_id = variant_hash[QLatin1String("id")].toInt();
  m_name = variant_hash[QLatin1String("name")].toString();
  m_description = variant_hash[QLatin1String("description")].toString();
}

Category::Category(const QVariantList & variants)
 : Category()
{
  m_id = variants[0].toInt();
  m_name = variants[1].toString();
  m_description = variants[2].toString();
}

Category::Category(const QSqlRecord & record)
 : QoRow<CategorySchema>(record)
{
  m_id = record.value(0).toInt();
  m_name = record.value(1).toString();
  m_description = record.value(2).toString();
}

Category::Category(const QSqlQuery & query, int offset)
 : QoRow<CategorySchema>(query)
{
  m_id = query.value(offset++).toInt();
  m_name = query.value(offset++).toString();
  m_description = query.value(offset).toString();
}

Category::~Category()
{
// qATInfo() << "--- Delete" << "Category" << *this;
}

// bit array ?
Category &
Category::operator=(const Category & other)
{
  if (this != &other) {
    QoRow<CategorySchema>::operator=(other);
    m_id = other.m_id;
    m_name = other.m_name;
    m_description = other.m_description;
  }

  return *this;
}

// bit array ?
bool
Category::operator==(const Category & other) const
{
  if (not QoRow<CategorySchema>::operator==(other))
    return false;
  if (m_id != other.m_id)
    return false;
  if (m_name != other.m_name)
    return false;
  if (m_description != other.m_description)
    return false;

  return true;
}

void
Category::set_id(int value)
{
  if (m_id != value) {
    m_id = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::ID);

    emit idChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Category::set_name(const QString & value)
{
  if (m_name != value) {
    m_name = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::NAME);

    emit nameChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Category::set_description(const QString & value)
{
  if (m_description != value) {
    m_description = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::DESCRIPTION);

    emit descriptionChanged();
    if (not is_changed)
      emit changed();
  }
}

QJsonObject
Category::to_json(bool only_changed) const
{
  QJsonObject json_object;

 if (only_changed) {
    if (is_id_modified())
      json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    if (is_name_modified())
      json_object.insert(QLatin1String("name"), QJsonValue(m_name));
    if (is_description_modified())
      json_object.insert(QLatin1String("description"), QJsonValue(m_description));
  } else {
    json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    json_object.insert(QLatin1String("name"), QJsonValue(m_name));
    json_object.insert(QLatin1String("description"), QJsonValue(m_description));
  }

  return json_object;
}

QVariantHash
Category::to_variant_hash(bool only_changed) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_name_modified())
      variant_hash[QLatin1String("name")] = m_name;
    if (is_description_modified())
      variant_hash[QLatin1String("description")] = m_description;
  } else {
    variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("name")] = m_name;
    variant_hash[QLatin1String("description")] = m_description;
  }

  return variant_hash;
}

QVariantList
Category::to_variant_list() const
{
  QVariantList variants;

  variants << m_id;
  variants << m_name;
  variants << m_description;

  return variants;
}

QVariantHash
Category::to_variant_hash_sql(bool only_changed, bool duplicate) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_name_modified())
      variant_hash[QLatin1String("name")] = m_name;
    if (is_description_modified())
      variant_hash[QLatin1String("description")] = m_description;
  } else {
    if (duplicate)
      variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("name")] = m_name;
    variant_hash[QLatin1String("description")] = m_description;
  }

  return variant_hash;
}

QVariantList
Category::to_variant_list_sql(bool duplicate) const
{
  QVariantList variants;

  if (duplicate)
    variants << m_id;
  variants << m_name;
  variants << m_description;

  return variants;
}

QVariant
Category::field(int position) const
{
  switch(position) {
   case Schema::Fields::ID:
     return m_id;
   case Schema::Fields::NAME:
     return m_name;
   case Schema::Fields::DESCRIPTION:
     return m_description;
   default:
     return QVariant(); // error
  }
}

void
Category::set_field(int position, const QVariant & value)
{
  switch(position) {
   case Schema::Fields::ID: {
     m_id = value.toInt();
     break;
   }
   case Schema::Fields::NAME: {
     m_name = value.toString();
     break;
   }
   case Schema::Fields::DESCRIPTION: {
     m_description = value.toString();
     break;
   }
  }
}

void
Category::set_insert_id(int id)
{
  set_id(id);

}

bool
Category::can_update() const
{
  return m_id > 0;
}

QVariantHash
Category::rowid_kwargs() const // To update row
{
  QVariantHash where_kwargs;
  where_kwargs[QLatin1String("id")] = m_id;
  return where_kwargs;
}

QDataStream &
operator<<(QDataStream & out, const Category & obj)
{
  out << obj.id();
  out << obj.name();
  out << obj.description();

  return out;
}

QDataStream &
operator>>(QDataStream & in, Category & obj)
{
  QString _QString;
  int _int;
  in >> _int;
  obj.set_id(_int);
  in >> _QString;
  obj.set_name(_QString);
  in >> _QString;
  obj.set_description(_QString);

  return in;
}

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const Category & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  // Fixme: quote string !
  debug.nospace() << QLatin1Literal("Category(");
  debug << obj.id();
  debug << QLatin1Literal(", ");
  debug << obj.name();
  debug << QLatin1Literal(", ");
  debug << obj.description();
  debug << ')';

  return debug;
}
#endif

/**************************************************************************************************/

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const CategoryPtr & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  debug.noquote() << QLatin1Literal("CategoryPtr ->");
  if (obj)
    debug << *obj;
   else
  debug  << QLatin1Literal("NULL");

  return debug;
}
#endif

/**************************************************************************************************/

CategoryCache::CategoryCache()
 : m_loaded_instances(),
   m_modified_instances()
{}

CategoryCache::~CategoryCache()
{}

void
CategoryCache::add(CategoryPtr & ptr)
{
  m_loaded_instances.insert(ptr.data(), ptr);
  QObject::connect(ptr.data(), &Category::changed,
                   this, &CategoryCache::on_changed);
}

void
CategoryCache::remove(CategoryPtr & ptr)
{
  Q_UNUSED(ptr);
}

void
CategoryCache::on_changed()
{
  Category * row = qobject_cast<Category *>(QObject::sender());
  qATInfo() << "On changed" << row;
  CategoryPtr row_ptr = m_loaded_instances[row];
  if (row_ptr)
    m_modified_instances.insert(row, row_ptr);
}

/**************************************************************************************************/

CategoryModel::CategoryModel()
  : QAbstractListModel(),
    m_items()
{}

CategoryModel::CategoryModel(const ItemList & items)
  : QAbstractListModel(),
    m_items(items)
{}

CategoryModel::~CategoryModel()
{}

int
CategoryModel::rowCount(const QModelIndex & parent) const
{
  Q_UNUSED(parent);
  return m_items.size();
}

QVariant
CategoryModel::data(const QModelIndex & index, int role) const
{
  if (!index.isValid() || index.row() < 0)
    return QVariant();

  if (index.row() >= m_items.count()) {
    qWarning() << "CategoryModel: Index out of bound";
    return QVariant();
  }

  const Item & item = m_items[index.row()];
  switch (role) {
  case ID:
    return item->id();
  case NAME:
    return item->name();
  case DESCRIPTION:
    return item->description();
  default:
    break;
  }

  return QVariant();
}

QHash<int, QByteArray>
CategoryModel::roleNames() const
{
  // Fixme: cache ???
  QHash<int, QByteArray> role_names;
  role_names[ID] = QLatin1Literal("id").latin1();
  role_names[NAME] = QLatin1Literal("name").latin1();
  role_names[DESCRIPTION] = QLatin1Literal("description").latin1();

  return role_names;
}

void
CategoryModel::clear_items()
{
  beginResetModel();
  m_items.clear();
  endResetModel();
}

void
CategoryModel::set_items(const ItemList & items)
{
  beginResetModel();
  m_items = items;
  endResetModel();
}

BlogSchema::BlogSchema()
: QoSchema(QLatin1String("Blog"), QLatin1String("blogs"))
{
  {
    QoSchemaPrimaryKey field(
      QLatin1String("id"),
      QLatin1String("int"),
      QLatin1String("integer"),
      QLatin1String("id"),
      QLatin1String("id"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    field.set_nullable(false);
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("text"),
      QLatin1String("QString"),
      QLatin1String("text"),
      QLatin1String("text"),
      QLatin1String("text"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("date"),
      QLatin1String("QDateTime"),
      QLatin1String("text"),
      QLatin1String("date"),
      QLatin1String("date"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
  {
    QoSchemaForeignKey field(
      QLatin1String("author_id"),
      QLatin1String("authors.id"),
      QLatin1String("int"),
      QLatin1String("integer"),
      QLatin1String("author_id"),
      QLatin1String("author_id"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
}

BlogSchema::~BlogSchema()
{}

/**************************************************************************************************/

Blog::Blog()
  : QObject(),
    QoRow<BlogSchema>(),
    m_id(),
    m_text(),
    m_date(),
    m_author_id()
{
}

Blog::Blog(const Blog & other)
  : QObject(),
    QoRow<BlogSchema>(other),
    m_id(other.m_id),
    m_text(other.m_text),
    m_date(other.m_date),
    m_author_id(other.m_author_id)
{
}

Blog::Blog(const QJsonObject & json_object)
 : Blog()
{
  m_id = json_object[QLatin1String("id")].toInt();
  m_text = json_object[QLatin1String("text")].toString();
  m_date = orm_type_conversion::load_datetime(json_object[QLatin1String("date")]);
  m_author_id = json_object[QLatin1String("author_id")].toInt();
}

Blog::Blog(const QVariantHash & variant_hash)
 : Blog()
{
  m_id = variant_hash[QLatin1String("id")].toInt();
  m_text = variant_hash[QLatin1String("text")].toString();
  m_date = variant_hash[QLatin1String("date")].toDateTime();
  m_author_id = variant_hash[QLatin1String("author_id")].toInt();
}

Blog::Blog(const QVariantList & variants)
 : Blog()
{
  m_id = variants[0].toInt();
  m_text = variants[1].toString();
  m_date = variants[2].toDateTime();
  m_author_id = variants[3].toInt();
}

Blog::Blog(const QSqlRecord & record)
 : QoRow<BlogSchema>(record)
{
  m_id = record.value(0).toInt();
  m_text = record.value(1).toString();
  m_date = record.value(2).toDateTime();
  m_author_id = record.value(3).toInt();
}

Blog::Blog(const QSqlQuery & query, int offset)
 : QoRow<BlogSchema>(query)
{
  m_id = query.value(offset++).toInt();
  m_text = query.value(offset++).toString();
  m_date = query.value(offset++).toDateTime();
  m_author_id = query.value(offset).toInt();
}

Blog::~Blog()
{
// qATInfo() << "--- Delete" << "Blog" << *this;
}

// bit array ?
Blog &
Blog::operator=(const Blog & other)
{
  if (this != &other) {
    QoRow<BlogSchema>::operator=(other);
    m_id = other.m_id;
    m_text = other.m_text;
    m_date = other.m_date;
    m_author_id = other.m_author_id;
  }

  return *this;
}

// bit array ?
bool
Blog::operator==(const Blog & other) const
{
  if (not QoRow<BlogSchema>::operator==(other))
    return false;
  if (m_id != other.m_id)
    return false;
  if (m_text != other.m_text)
    return false;
  if (m_date != other.m_date)
    return false;
  if (m_author_id != other.m_author_id)
    return false;

  return true;
}

void
Blog::set_id(int value)
{
  if (m_id != value) {
    m_id = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::ID);

    emit idChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Blog::set_text(const QString & value)
{
  if (m_text != value) {
    m_text = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::TEXT);

    emit textChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Blog::set_date(const QDateTime & value)
{
  if (m_date != value) {
    m_date = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::DATE);

    emit dateChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Blog::set_author_id(int value)
{
  if (m_author_id != value) {
    m_author_id = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::AUTHOR_ID);

    emit author_idChanged();
    if (not is_changed)
      emit changed();
  }
}

QJsonObject
Blog::to_json(bool only_changed) const
{
  QJsonObject json_object;

 if (only_changed) {
    if (is_id_modified())
      json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    if (is_text_modified())
      json_object.insert(QLatin1String("text"), QJsonValue(m_text));
    if (is_date_modified())
      json_object.insert(QLatin1String("date"), orm_type_conversion::dump_datetime(m_date));
    if (is_author_id_modified())
      json_object.insert(QLatin1String("author_id"), QJsonValue(m_author_id));
  } else {
    json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    json_object.insert(QLatin1String("text"), QJsonValue(m_text));
    json_object.insert(QLatin1String("date"), orm_type_conversion::dump_datetime(m_date));
    json_object.insert(QLatin1String("author_id"), QJsonValue(m_author_id));
  }

  return json_object;
}

QVariantHash
Blog::to_variant_hash(bool only_changed) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_text_modified())
      variant_hash[QLatin1String("text")] = m_text;
    if (is_date_modified())
      variant_hash[QLatin1String("date")] = m_date;
    if (is_author_id_modified())
      variant_hash[QLatin1String("author_id")] = m_author_id;
  } else {
    variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("text")] = m_text;
    variant_hash[QLatin1String("date")] = m_date;
    variant_hash[QLatin1String("author_id")] = m_author_id;
  }

  return variant_hash;
}

QVariantList
Blog::to_variant_list() const
{
  QVariantList variants;

  variants << m_id;
  variants << m_text;
  variants << m_date;
  variants << m_author_id;

  return variants;
}

QVariantHash
Blog::to_variant_hash_sql(bool only_changed, bool duplicate) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_text_modified())
      variant_hash[QLatin1String("text")] = m_text;
    if (is_date_modified())
      variant_hash[QLatin1String("date")] = m_date;
    if (is_author_id_modified())
      variant_hash[QLatin1String("author_id")] = m_author_id;
  } else {
    if (duplicate)
      variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("text")] = m_text;
    variant_hash[QLatin1String("date")] = m_date;
    variant_hash[QLatin1String("author_id")] = m_author_id;
  }

  return variant_hash;
}

QVariantList
Blog::to_variant_list_sql(bool duplicate) const
{
  QVariantList variants;

  if (duplicate)
    variants << m_id;
  variants << m_text;
  variants << m_date;
  variants << m_author_id;

  return variants;
}

QVariant
Blog::field(int position) const
{
  switch(position) {
   case Schema::Fields::ID:
     return m_id;
   case Schema::Fields::TEXT:
     return m_text;
   case Schema::Fields::DATE:
     return m_date;
   case Schema::Fields::AUTHOR_ID:
     return m_author_id;
   default:
     return QVariant(); // error
  }
}

void
Blog::set_field(int position, const QVariant & value)
{
  switch(position) {
   case Schema::Fields::ID: {
     m_id = value.toInt();
     break;
   }
   case Schema::Fields::TEXT: {
     m_text = value.toString();
     break;
   }
   case Schema::Fields::DATE: {
     m_date = value.toDateTime();
     break;
   }
   case Schema::Fields::AUTHOR_ID: {
     m_author_id = value.toInt();
     break;
   }
  }
}

void
Blog::set_insert_id(int id)
{
  set_id(id);

}

bool
Blog::can_save() const
{
  if (m_author_id == 0)
    return false;

  return true;
}

void
Blog::load_relations()
{
  qATInfo() << "Load relations of" << *this;
  author();
}

void
Blog::save_relations()
{
  qATInfo() << "Save relations of" << *this;
}

AuthorPtr
Blog::author()
{
  if (m_author.isNull())
    // Fixme: query_by_id must be defined in QoDatabaseSchema but we cannot call register_row
    m_author = database_schema()->query_by_id<Author>(m_author_id);
  return m_author;
}

bool
Blog::can_update() const
{
  return m_id > 0;
}

QVariantHash
Blog::rowid_kwargs() const // To update row
{
  QVariantHash where_kwargs;
  where_kwargs[QLatin1String("id")] = m_id;
  return where_kwargs;
}

QDataStream &
operator<<(QDataStream & out, const Blog & obj)
{
  out << obj.id();
  out << obj.text();
  out << obj.date();
  out << obj.author_id();

  return out;
}

QDataStream &
operator>>(QDataStream & in, Blog & obj)
{
  QDateTime _QDateTime;
  QString _QString;
  int _int;
  in >> _int;
  obj.set_id(_int);
  in >> _QString;
  obj.set_text(_QString);
  in >> _QDateTime;
  obj.set_date(_QDateTime);
  in >> _int;
  obj.set_author_id(_int);

  return in;
}

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const Blog & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  // Fixme: quote string !
  debug.nospace() << QLatin1Literal("Blog(");
  debug << obj.id();
  debug << QLatin1Literal(", ");
  debug << obj.text();
  debug << QLatin1Literal(", ");
  debug << obj.date();
  debug << QLatin1Literal(", ");
  debug << obj.author_id();
  debug << ')';

  return debug;
}
#endif

/**************************************************************************************************/

void
BlogPtr::set_author(AuthorPtr & value)
{
  if (m_ptr->m_author)
    m_ptr->m_author->blogs().remove(*this);
  m_ptr->m_author = value;
  m_ptr->set_author_id(value->id());
  value->blogs().append(*this);
}

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const BlogPtr & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  debug.noquote() << QLatin1Literal("BlogPtr ->");
  if (obj)
    debug << *obj;
   else
  debug  << QLatin1Literal("NULL");

  return debug;
}
#endif

/**************************************************************************************************/

BlogCache::BlogCache()
 : m_loaded_instances(),
   m_modified_instances()
{}

BlogCache::~BlogCache()
{}

void
BlogCache::add(BlogPtr & ptr)
{
  m_loaded_instances.insert(ptr.data(), ptr);
  QObject::connect(ptr.data(), &Blog::changed,
                   this, &BlogCache::on_changed);
}

void
BlogCache::remove(BlogPtr & ptr)
{
  Q_UNUSED(ptr);
}

void
BlogCache::on_changed()
{
  Blog * row = qobject_cast<Blog *>(QObject::sender());
  qATInfo() << "On changed" << row;
  BlogPtr row_ptr = m_loaded_instances[row];
  if (row_ptr)
    m_modified_instances.insert(row, row_ptr);
}

/**************************************************************************************************/

BlogModel::BlogModel()
  : QAbstractListModel(),
    m_items()
{}

BlogModel::BlogModel(const ItemList & items)
  : QAbstractListModel(),
    m_items(items)
{}

BlogModel::~BlogModel()
{}

int
BlogModel::rowCount(const QModelIndex & parent) const
{
  Q_UNUSED(parent);
  return m_items.size();
}

QVariant
BlogModel::data(const QModelIndex & index, int role) const
{
  if (!index.isValid() || index.row() < 0)
    return QVariant();

  if (index.row() >= m_items.count()) {
    qWarning() << "BlogModel: Index out of bound";
    return QVariant();
  }

  const Item & item = m_items[index.row()];
  switch (role) {
  case ID:
    return item->id();
  case TEXT:
    return item->text();
  case DATE:
    return item->date();
  case AUTHOR_ID:
    return item->author_id();
  default:
    break;
  }

  return QVariant();
}

QHash<int, QByteArray>
BlogModel::roleNames() const
{
  // Fixme: cache ???
  QHash<int, QByteArray> role_names;
  role_names[ID] = QLatin1Literal("id").latin1();
  role_names[TEXT] = QLatin1Literal("text").latin1();
  role_names[DATE] = QLatin1Literal("date").latin1();
  role_names[AUTHOR_ID] = QLatin1Literal("author_id").latin1();

  return role_names;
}

void
BlogModel::clear_items()
{
  beginResetModel();
  m_items.clear();
  endResetModel();
}

void
BlogModel::set_items(const ItemList & items)
{
  beginResetModel();
  m_items = items;
  endResetModel();
}

CommentSchema::CommentSchema()
: QoSchema(QLatin1String("Comment"), QLatin1String("comments"))
{
  {
    QoSchemaPrimaryKey field(
      QLatin1String("id"),
      QLatin1String("int"),
      QLatin1String("integer"),
      QLatin1String("id"),
      QLatin1String("id"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    field.set_nullable(false);
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("text"),
      QLatin1String("QString"),
      QLatin1String("text"),
      QLatin1String("text"),
      QLatin1String("text"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
  {
    QoSchemaField field(
      QLatin1String("date"),
      QLatin1String("QDateTime"),
      QLatin1String("text"),
      QLatin1String("date"),
      QLatin1String("date"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
  {
    QoSchemaForeignKey field(
      QLatin1String("blog_id"),
      QLatin1String("blogs.id"),
      QLatin1String("int"),
      QLatin1String("integer"),
      QLatin1String("blog_id"),
      QLatin1String("blog_id"),
      QLatin1String(""),
      QLatin1String(""));
    // Optional parameters
    add_field(field);
  }
}

CommentSchema::~CommentSchema()
{}

/**************************************************************************************************/

Comment::Comment()
  : QObject(),
    QoRow<CommentSchema>(),
    m_id(),
    m_text(),
    m_date(),
    m_blog_id()
{
}

Comment::Comment(const Comment & other)
  : QObject(),
    QoRow<CommentSchema>(other),
    m_id(other.m_id),
    m_text(other.m_text),
    m_date(other.m_date),
    m_blog_id(other.m_blog_id)
{
}

Comment::Comment(const QJsonObject & json_object)
 : Comment()
{
  m_id = json_object[QLatin1String("id")].toInt();
  m_text = json_object[QLatin1String("text")].toString();
  m_date = orm_type_conversion::load_datetime(json_object[QLatin1String("date")]);
  m_blog_id = json_object[QLatin1String("blog_id")].toInt();
}

Comment::Comment(const QVariantHash & variant_hash)
 : Comment()
{
  m_id = variant_hash[QLatin1String("id")].toInt();
  m_text = variant_hash[QLatin1String("text")].toString();
  m_date = variant_hash[QLatin1String("date")].toDateTime();
  m_blog_id = variant_hash[QLatin1String("blog_id")].toInt();
}

Comment::Comment(const QVariantList & variants)
 : Comment()
{
  m_id = variants[0].toInt();
  m_text = variants[1].toString();
  m_date = variants[2].toDateTime();
  m_blog_id = variants[3].toInt();
}

Comment::Comment(const QSqlRecord & record)
 : QoRow<CommentSchema>(record)
{
  m_id = record.value(0).toInt();
  m_text = record.value(1).toString();
  m_date = record.value(2).toDateTime();
  m_blog_id = record.value(3).toInt();
}

Comment::Comment(const QSqlQuery & query, int offset)
 : QoRow<CommentSchema>(query)
{
  m_id = query.value(offset++).toInt();
  m_text = query.value(offset++).toString();
  m_date = query.value(offset++).toDateTime();
  m_blog_id = query.value(offset).toInt();
}

Comment::~Comment()
{
// qATInfo() << "--- Delete" << "Comment" << *this;
}

// bit array ?
Comment &
Comment::operator=(const Comment & other)
{
  if (this != &other) {
    QoRow<CommentSchema>::operator=(other);
    m_id = other.m_id;
    m_text = other.m_text;
    m_date = other.m_date;
    m_blog_id = other.m_blog_id;
  }

  return *this;
}

// bit array ?
bool
Comment::operator==(const Comment & other) const
{
  if (not QoRow<CommentSchema>::operator==(other))
    return false;
  if (m_id != other.m_id)
    return false;
  if (m_text != other.m_text)
    return false;
  if (m_date != other.m_date)
    return false;
  if (m_blog_id != other.m_blog_id)
    return false;

  return true;
}

void
Comment::set_id(int value)
{
  if (m_id != value) {
    m_id = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::ID);

    emit idChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Comment::set_text(const QString & value)
{
  if (m_text != value) {
    m_text = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::TEXT);

    emit textChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Comment::set_date(const QDateTime & value)
{
  if (m_date != value) {
    m_date = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::DATE);

    emit dateChanged();
    if (not is_changed)
      emit changed();
  }
}

void
Comment::set_blog_id(int value)
{
  if (m_blog_id != value) {
    m_blog_id = value;

    bool is_changed = is_modified();
    set_bit(Schema::Fields::BLOG_ID);

    emit blog_idChanged();
    if (not is_changed)
      emit changed();
  }
}

QJsonObject
Comment::to_json(bool only_changed) const
{
  QJsonObject json_object;

 if (only_changed) {
    if (is_id_modified())
      json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    if (is_text_modified())
      json_object.insert(QLatin1String("text"), QJsonValue(m_text));
    if (is_date_modified())
      json_object.insert(QLatin1String("date"), orm_type_conversion::dump_datetime(m_date));
    if (is_blog_id_modified())
      json_object.insert(QLatin1String("blog_id"), QJsonValue(m_blog_id));
  } else {
    json_object.insert(QLatin1String("id"), QJsonValue(m_id));
    json_object.insert(QLatin1String("text"), QJsonValue(m_text));
    json_object.insert(QLatin1String("date"), orm_type_conversion::dump_datetime(m_date));
    json_object.insert(QLatin1String("blog_id"), QJsonValue(m_blog_id));
  }

  return json_object;
}

QVariantHash
Comment::to_variant_hash(bool only_changed) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_text_modified())
      variant_hash[QLatin1String("text")] = m_text;
    if (is_date_modified())
      variant_hash[QLatin1String("date")] = m_date;
    if (is_blog_id_modified())
      variant_hash[QLatin1String("blog_id")] = m_blog_id;
  } else {
    variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("text")] = m_text;
    variant_hash[QLatin1String("date")] = m_date;
    variant_hash[QLatin1String("blog_id")] = m_blog_id;
  }

  return variant_hash;
}

QVariantList
Comment::to_variant_list() const
{
  QVariantList variants;

  variants << m_id;
  variants << m_text;
  variants << m_date;
  variants << m_blog_id;

  return variants;
}

QVariantHash
Comment::to_variant_hash_sql(bool only_changed, bool duplicate) const
{
  QVariantHash variant_hash;

  if (only_changed) {
    if (is_id_modified())
      variant_hash[QLatin1String("id")] = m_id;
    if (is_text_modified())
      variant_hash[QLatin1String("text")] = m_text;
    if (is_date_modified())
      variant_hash[QLatin1String("date")] = m_date;
    if (is_blog_id_modified())
      variant_hash[QLatin1String("blog_id")] = m_blog_id;
  } else {
    if (duplicate)
      variant_hash[QLatin1String("id")] = m_id;
    variant_hash[QLatin1String("text")] = m_text;
    variant_hash[QLatin1String("date")] = m_date;
    variant_hash[QLatin1String("blog_id")] = m_blog_id;
  }

  return variant_hash;
}

QVariantList
Comment::to_variant_list_sql(bool duplicate) const
{
  QVariantList variants;

  if (duplicate)
    variants << m_id;
  variants << m_text;
  variants << m_date;
  variants << m_blog_id;

  return variants;
}

QVariant
Comment::field(int position) const
{
  switch(position) {
   case Schema::Fields::ID:
     return m_id;
   case Schema::Fields::TEXT:
     return m_text;
   case Schema::Fields::DATE:
     return m_date;
   case Schema::Fields::BLOG_ID:
     return m_blog_id;
   default:
     return QVariant(); // error
  }
}

void
Comment::set_field(int position, const QVariant & value)
{
  switch(position) {
   case Schema::Fields::ID: {
     m_id = value.toInt();
     break;
   }
   case Schema::Fields::TEXT: {
     m_text = value.toString();
     break;
   }
   case Schema::Fields::DATE: {
     m_date = value.toDateTime();
     break;
   }
   case Schema::Fields::BLOG_ID: {
     m_blog_id = value.toInt();
     break;
   }
  }
}

void
Comment::set_insert_id(int id)
{
  set_id(id);

}

bool
Comment::can_update() const
{
  return m_id > 0;
}

QVariantHash
Comment::rowid_kwargs() const // To update row
{
  QVariantHash where_kwargs;
  where_kwargs[QLatin1String("id")] = m_id;
  return where_kwargs;
}

QDataStream &
operator<<(QDataStream & out, const Comment & obj)
{
  out << obj.id();
  out << obj.text();
  out << obj.date();
  out << obj.blog_id();

  return out;
}

QDataStream &
operator>>(QDataStream & in, Comment & obj)
{
  QDateTime _QDateTime;
  QString _QString;
  int _int;
  in >> _int;
  obj.set_id(_int);
  in >> _QString;
  obj.set_text(_QString);
  in >> _QDateTime;
  obj.set_date(_QDateTime);
  in >> _int;
  obj.set_blog_id(_int);

  return in;
}

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const Comment & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  // Fixme: quote string !
  debug.nospace() << QLatin1Literal("Comment(");
  debug << obj.id();
  debug << QLatin1Literal(", ");
  debug << obj.text();
  debug << QLatin1Literal(", ");
  debug << obj.date();
  debug << QLatin1Literal(", ");
  debug << obj.blog_id();
  debug << ')';

  return debug;
}
#endif

/**************************************************************************************************/

#ifndef QT_NO_DEBUG_STREAM
QDebug
operator<<(QDebug debug, const CommentPtr & obj)
{
  QDebugStateSaver saver(debug); // Fixme: ???

  debug.noquote() << QLatin1Literal("CommentPtr ->");
  if (obj)
    debug << *obj;
   else
  debug  << QLatin1Literal("NULL");

  return debug;
}
#endif

/**************************************************************************************************/

CommentCache::CommentCache()
 : m_loaded_instances(),
   m_modified_instances()
{}

CommentCache::~CommentCache()
{}

void
CommentCache::add(CommentPtr & ptr)
{
  m_loaded_instances.insert(ptr.data(), ptr);
  QObject::connect(ptr.data(), &Comment::changed,
                   this, &CommentCache::on_changed);
}

void
CommentCache::remove(CommentPtr & ptr)
{
  Q_UNUSED(ptr);
}

void
CommentCache::on_changed()
{
  Comment * row = qobject_cast<Comment *>(QObject::sender());
  qATInfo() << "On changed" << row;
  CommentPtr row_ptr = m_loaded_instances[row];
  if (row_ptr)
    m_modified_instances.insert(row, row_ptr);
}

/**************************************************************************************************/

CommentModel::CommentModel()
  : QAbstractListModel(),
    m_items()
{}

CommentModel::CommentModel(const ItemList & items)
  : QAbstractListModel(),
    m_items(items)
{}

CommentModel::~CommentModel()
{}

int
CommentModel::rowCount(const QModelIndex & parent) const
{
  Q_UNUSED(parent);
  return m_items.size();
}

QVariant
CommentModel::data(const QModelIndex & index, int role) const
{
  if (!index.isValid() || index.row() < 0)
    return QVariant();

  if (index.row() >= m_items.count()) {
    qWarning() << "CommentModel: Index out of bound";
    return QVariant();
  }

  const Item & item = m_items[index.row()];
  switch (role) {
  case ID:
    return item->id();
  case TEXT:
    return item->text();
  case DATE:
    return item->date();
  case BLOG_ID:
    return item->blog_id();
  default:
    break;
  }

  return QVariant();
}

QHash<int, QByteArray>
CommentModel::roleNames() const
{
  // Fixme: cache ???
  QHash<int, QByteArray> role_names;
  role_names[ID] = QLatin1Literal("id").latin1();
  role_names[TEXT] = QLatin1Literal("text").latin1();
  role_names[DATE] = QLatin1Literal("date").latin1();
  role_names[BLOG_ID] = QLatin1Literal("blog_id").latin1();

  return role_names;
}

void
CommentModel::clear_items()
{
  beginResetModel();
  m_items.clear();
  endResetModel();
}

void
CommentModel::set_items(const ItemList & items)
{
  beginResetModel();
  m_items = items;
  endResetModel();
}
BlogApplicationSchema::BlogApplicationSchema(QoDatabase & database)
  : QoDatabaseSchema(database),
    m_authors(nullptr),
    m_categories(nullptr),
    m_blogs(nullptr),
    m_comments(nullptr),
    m_authors_cache(),
    m_categories_cache(),
    m_blogs_cache(),
    m_comments_cache()
{
  m_authors = &register_table(AuthorSchema::instance());
  m_categories = &register_table(CategorySchema::instance());
  m_blogs = &register_table(BlogSchema::instance());
  m_comments = &register_table(CommentSchema::instance());
}

BlogApplicationSchema::~BlogApplicationSchema()
{}

template<>
void
BlogApplicationSchema::register_row<Author>(AuthorPtr & row)
{
  qATInfo() << "Register in cache" << row;
  m_authors_cache.add(row);
}
template<>
void
BlogApplicationSchema::register_row<Category>(CategoryPtr & row)
{
  qATInfo() << "Register in cache" << row;
  m_categories_cache.add(row);
}
template<>
void
BlogApplicationSchema::register_row<Blog>(BlogPtr & row)
{
  qATInfo() << "Register in cache" << row;
  m_blogs_cache.add(row);
}
template<>
void
BlogApplicationSchema::register_row<Comment>(CommentPtr & row)
{
  qATInfo() << "Register in cache" << row;
  m_comments_cache.add(row);
}

/**************************************************************************************************/
// QC_END_NAMESPACE