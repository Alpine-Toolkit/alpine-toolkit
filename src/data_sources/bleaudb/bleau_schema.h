// -*- mode: c++ -*-
// This file was automatically generated by SqlOrm

/***************************************************************************************************
 *
** This file is part of the Alpine Toolkit software.
** Copyright (C) 2017 Fabrice Salvaire
** Contact: http://www.fabrice-salvaire.fr
** SPDX-License-Identifier: GPL-3.0-only
 *
 **************************************************************************************************/

/**************************************************************************************************/

#ifndef __BLEAU_SCHEMA_H__
#define __BLEAU_SCHEMA_H__

/**************************************************************************************************/

#define QT_SHAREDPOINTER_TRACK_POINTERS // For dubug purpose

#include "alpine_toolkit.h"
#include "orm/database_row.h"
#include "orm/database_row_list.h"
#include "orm/database_schema.h"
#include "orm/schema.h"

#include <QAbstractListModel>
#include <QDataStream>
#include <QGeoCoordinate>
#include <QJsonObject>
#include <QMap>
#include <QSharedPointer>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QString>
#include <QStringList>
#include <QtDebug>
#include <QVariant>
#include <QVariantList>

/**************************************************************************************************/

class BleauPlace;
class BleauPlacePtr;

/**************************************************************************************************/

class BleauPlaceSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    COORDINATE,
    NAME,
    CATEGORY,
    NOTE
  };
  static const int NUMBER_OF_FIELDS = 5;

public:
  static BleauPlaceSchema & instance()
  {
    static BleauPlaceSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  BleauPlaceSchema(const BleauPlaceSchema &) = delete;
  BleauPlaceSchema(BleauPlaceSchema &&) = delete;
  BleauPlaceSchema & operator=(const BleauPlaceSchema &) = delete;
  BleauPlaceSchema & operator=(BleauPlaceSchema &&) = delete;

protected:
  BleauPlaceSchema();
  ~BleauPlaceSchema();
};

/**************************************************************************************************/

class BleauPlace : public QObject, public QoRow<BleauPlaceSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QGeoCoordinate coordinate READ coordinate WRITE set_coordinate NOTIFY coordinateChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(QString category READ category WRITE set_category NOTIFY categoryChanged)
  Q_PROPERTY(QString note READ note WRITE set_note NOTIFY noteChanged)

public:
  typedef BleauPlacePtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class BleauPlacePtr;

public:
  BleauPlace();
  BleauPlace(const BleauPlace & other);
  BleauPlace(const QJsonObject & json_object); // JSON deserializer
  BleauPlace(const QVariantHash & variant_hash);
  BleauPlace(const QVariantList & variants);
  BleauPlace(const QSqlRecord & record); // SQL deserializer
  BleauPlace(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~BleauPlace();

  BleauPlace & operator=(const BleauPlace & other);

  bool operator==(const BleauPlace & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QGeoCoordinate & coordinate() const { return m_coordinate; }
  void set_coordinate(const QGeoCoordinate & value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  const QString & category() const { return m_category; }
  void set_category(const QString & value);

  const QString & note() const { return m_note; }
  void set_note(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_coordinate_modified() const { return bit_status(Schema::Fields::COORDINATE); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_category_modified() const { return bit_status(Schema::Fields::CATEGORY); }
  bool is_note_modified() const { return bit_status(Schema::Fields::NOTE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void coordinateChanged();
  void nameChanged();
  void categoryChanged();
  void noteChanged();

private:
  int m_id;
  QGeoCoordinate m_coordinate;
  QString m_name;
  QString m_category;
  QString m_note;

};

QDataStream & operator<<(QDataStream & out, const BleauPlace & obj);
QDataStream & operator>>(QDataStream & in, BleauPlace & obj);
// qRegisterMetaTypeStreamOperators<BleauPlace>("BleauPlace");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauPlace & obj);
#endif

/**************************************************************************************************/

class BleauPlacePtr
{
public:
  typedef BleauPlace Class;

public:
  BleauPlacePtr() : m_ptr() {}
  BleauPlacePtr(const BleauPlacePtr & other) : m_ptr(other.m_ptr) {}
  ~BleauPlacePtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete BleauPlacePtr of" << *m_ptr;
    // qATInfo() << "--- Delete BleauPlacePtr";
    // m_ptr.clear();
  }

  BleauPlacePtr & operator=(const BleauPlacePtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  BleauPlacePtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  BleauPlacePtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  BleauPlacePtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  BleauPlacePtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  BleauPlacePtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  BleauPlacePtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  BleauPlacePtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const BleauPlacePtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const BleauPlacePtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauPlacePtr & obj);
#endif

/**************************************************************************************************/

class BleauPlaceCache : public QObject
{
  Q_OBJECT

public:
  typedef BleauPlace * t_Key;
  typedef BleauPlacePtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  BleauPlaceCache();
  ~BleauPlaceCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class BleauPlaceModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef BleauPlacePtr Item;
  typedef QList<Item> ItemList;

public:
  BleauPlaceModel();
  BleauPlaceModel(const ItemList & items);
  ~BleauPlaceModel();

  // Fixme: use BleauPlaceSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    COORDINATE,
    NAME,
    CATEGORY,
    NOTE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class BleauMassif;
class BleauMassifPtr;

class BleauCircuit;
class BleauCircuitPtr;

/**************************************************************************************************/

class BleauMassifSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    COORDINATE,
    NAME,
    ACCESS,
    ALTERNATIVE_NAME,
    CHAOS_TYPE,
    NOTE,
    PARCELLES,
    RDV,
    SECTEUR,
    VELO
  };
  static const int NUMBER_OF_FIELDS = 11;

public:
  static BleauMassifSchema & instance()
  {
    static BleauMassifSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  BleauMassifSchema(const BleauMassifSchema &) = delete;
  BleauMassifSchema(BleauMassifSchema &&) = delete;
  BleauMassifSchema & operator=(const BleauMassifSchema &) = delete;
  BleauMassifSchema & operator=(BleauMassifSchema &&) = delete;

protected:
  BleauMassifSchema();
  ~BleauMassifSchema();
};

/**************************************************************************************************/

class BleauMassif : public QObject, public QoRow<BleauMassifSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QGeoCoordinate coordinate READ coordinate WRITE set_coordinate NOTIFY coordinateChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(QString access READ access WRITE set_access NOTIFY accessChanged)
  Q_PROPERTY(QString alternative_name READ alternative_name WRITE set_alternative_name NOTIFY alternative_nameChanged)
  Q_PROPERTY(QString chaos_type READ chaos_type WRITE set_chaos_type NOTIFY chaos_typeChanged)
  Q_PROPERTY(QString note READ note WRITE set_note NOTIFY noteChanged)
  Q_PROPERTY(QString parcelles READ parcelles WRITE set_parcelles NOTIFY parcellesChanged)
  Q_PROPERTY(QString rdv READ rdv WRITE set_rdv NOTIFY rdvChanged)
  Q_PROPERTY(QString secteur READ secteur WRITE set_secteur NOTIFY secteurChanged)
  Q_PROPERTY(QString velo READ velo WRITE set_velo NOTIFY veloChanged)

public:
  typedef BleauMassifPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class BleauMassifPtr;

public:
  BleauMassif();
  BleauMassif(const BleauMassif & other);
  BleauMassif(const QJsonObject & json_object); // JSON deserializer
  BleauMassif(const QVariantHash & variant_hash);
  BleauMassif(const QVariantList & variants);
  BleauMassif(const QSqlRecord & record); // SQL deserializer
  BleauMassif(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~BleauMassif();

  BleauMassif & operator=(const BleauMassif & other);

  bool operator==(const BleauMassif & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QGeoCoordinate & coordinate() const { return m_coordinate; }
  void set_coordinate(const QGeoCoordinate & value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  const QString & access() const { return m_access; }
  void set_access(const QString & value);

  const QString & alternative_name() const { return m_alternative_name; }
  void set_alternative_name(const QString & value);

  const QString & chaos_type() const { return m_chaos_type; }
  void set_chaos_type(const QString & value);

  const QString & note() const { return m_note; }
  void set_note(const QString & value);

  const QString & parcelles() const { return m_parcelles; }
  void set_parcelles(const QString & value);

  const QString & rdv() const { return m_rdv; }
  void set_rdv(const QString & value);

  const QString & secteur() const { return m_secteur; }
  void set_secteur(const QString & value);

  const QString & velo() const { return m_velo; }
  void set_velo(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_coordinate_modified() const { return bit_status(Schema::Fields::COORDINATE); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_access_modified() const { return bit_status(Schema::Fields::ACCESS); }
  bool is_alternative_name_modified() const { return bit_status(Schema::Fields::ALTERNATIVE_NAME); }
  bool is_chaos_type_modified() const { return bit_status(Schema::Fields::CHAOS_TYPE); }
  bool is_note_modified() const { return bit_status(Schema::Fields::NOTE); }
  bool is_parcelles_modified() const { return bit_status(Schema::Fields::PARCELLES); }
  bool is_rdv_modified() const { return bit_status(Schema::Fields::RDV); }
  bool is_secteur_modified() const { return bit_status(Schema::Fields::SECTEUR); }
  bool is_velo_modified() const { return bit_status(Schema::Fields::VELO); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  void load_relations();
  void save_relations();

  QoRowList<BleauCircuit, BleauCircuitPtr> & circuits() { return m_circuits; }

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void coordinateChanged();
  void nameChanged();
  void accessChanged();
  void alternative_nameChanged();
  void chaos_typeChanged();
  void noteChanged();
  void parcellesChanged();
  void rdvChanged();
  void secteurChanged();
  void veloChanged();

private:
  int m_id;
  QGeoCoordinate m_coordinate;
  QString m_name;
  QString m_access;
  QString m_alternative_name;
  QString m_chaos_type;
  QString m_note;
  QString m_parcelles;
  QString m_rdv;
  QString m_secteur;
  QString m_velo;
  QoRowList<BleauCircuit, BleauCircuitPtr> m_circuits;

};

QDataStream & operator<<(QDataStream & out, const BleauMassif & obj);
QDataStream & operator>>(QDataStream & in, BleauMassif & obj);
// qRegisterMetaTypeStreamOperators<BleauMassif>("BleauMassif");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauMassif & obj);
#endif

/**************************************************************************************************/

class BleauMassifPtr
{
public:
  typedef BleauMassif Class;

public:
  BleauMassifPtr() : m_ptr() {}
  BleauMassifPtr(const BleauMassifPtr & other) : m_ptr(other.m_ptr) {}
  ~BleauMassifPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete BleauMassifPtr of" << *m_ptr;
    // qATInfo() << "--- Delete BleauMassifPtr";
    // m_ptr.clear();
  }

  BleauMassifPtr & operator=(const BleauMassifPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  BleauMassifPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  BleauMassifPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  BleauMassifPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  BleauMassifPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  BleauMassifPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  BleauMassifPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  BleauMassifPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const BleauMassifPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const BleauMassifPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauMassifPtr & obj);
#endif

/**************************************************************************************************/

class BleauMassifCache : public QObject
{
  Q_OBJECT

public:
  typedef BleauMassif * t_Key;
  typedef BleauMassifPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  BleauMassifCache();
  ~BleauMassifCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class BleauMassifModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef BleauMassifPtr Item;
  typedef QList<Item> ItemList;

public:
  BleauMassifModel();
  BleauMassifModel(const ItemList & items);
  ~BleauMassifModel();

  // Fixme: use BleauMassifSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    COORDINATE,
    NAME,
    ACCESS,
    ALTERNATIVE_NAME,
    CHAOS_TYPE,
    NOTE,
    PARCELLES,
    RDV,
    SECTEUR,
    VELO
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class BleauCircuit;
class BleauCircuitPtr;

class BleauBoulder;
class BleauBoulderPtr;

/**************************************************************************************************/

class BleauCircuitSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    COORDINATE,
    COLOUR,
    CREATION_DATE,
    GESTION,
    GRADE,
    MASSIF_ID,
    NOTE,
    NUMBER,
    OPENER,
    REFECTION_DATE,
    REFECTION_NOTE,
    STATUS,
    TOPOS
  };
  static const int NUMBER_OF_FIELDS = 14;

public:
  static BleauCircuitSchema & instance()
  {
    static BleauCircuitSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  BleauCircuitSchema(const BleauCircuitSchema &) = delete;
  BleauCircuitSchema(BleauCircuitSchema &&) = delete;
  BleauCircuitSchema & operator=(const BleauCircuitSchema &) = delete;
  BleauCircuitSchema & operator=(BleauCircuitSchema &&) = delete;

protected:
  BleauCircuitSchema();
  ~BleauCircuitSchema();
};

/**************************************************************************************************/

class BleauCircuit : public QObject, public QoRow<BleauCircuitSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QGeoCoordinate coordinate READ coordinate WRITE set_coordinate NOTIFY coordinateChanged)
  Q_PROPERTY(QString colour READ colour WRITE set_colour NOTIFY colourChanged)
  Q_PROPERTY(int creation_date READ creation_date WRITE set_creation_date NOTIFY creation_dateChanged)
  Q_PROPERTY(QString gestion READ gestion WRITE set_gestion NOTIFY gestionChanged)
  Q_PROPERTY(QString grade READ grade WRITE set_grade NOTIFY gradeChanged)
  Q_PROPERTY(int massif_id READ massif_id WRITE set_massif_id NOTIFY massif_idChanged)
  Q_PROPERTY(QString note READ note WRITE set_note NOTIFY noteChanged)
  Q_PROPERTY(int number READ number WRITE set_number NOTIFY numberChanged)
  Q_PROPERTY(QString opener READ opener WRITE set_opener NOTIFY openerChanged)
  Q_PROPERTY(int refection_date READ refection_date WRITE set_refection_date NOTIFY refection_dateChanged)
  Q_PROPERTY(QString refection_note READ refection_note WRITE set_refection_note NOTIFY refection_noteChanged)
  Q_PROPERTY(QString status READ status WRITE set_status NOTIFY statusChanged)
  Q_PROPERTY(QStringList topos READ topos WRITE set_topos NOTIFY toposChanged)

public:
  typedef BleauCircuitPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class BleauCircuitPtr;

public:
  BleauCircuit();
  BleauCircuit(const BleauCircuit & other);
  BleauCircuit(const QJsonObject & json_object); // JSON deserializer
  BleauCircuit(const QVariantHash & variant_hash);
  BleauCircuit(const QVariantList & variants);
  BleauCircuit(const QSqlRecord & record); // SQL deserializer
  BleauCircuit(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~BleauCircuit();

  BleauCircuit & operator=(const BleauCircuit & other);

  bool operator==(const BleauCircuit & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QGeoCoordinate & coordinate() const { return m_coordinate; }
  void set_coordinate(const QGeoCoordinate & value);

  const QString & colour() const { return m_colour; }
  void set_colour(const QString & value);

  int creation_date() const { return m_creation_date; }
  void set_creation_date(int value);

  const QString & gestion() const { return m_gestion; }
  void set_gestion(const QString & value);

  const QString & grade() const { return m_grade; }
  void set_grade(const QString & value);

  int massif_id() const { return m_massif_id; }
  void set_massif_id(int value);

  const QString & note() const { return m_note; }
  void set_note(const QString & value);

  int number() const { return m_number; }
  void set_number(int value);

  const QString & opener() const { return m_opener; }
  void set_opener(const QString & value);

  int refection_date() const { return m_refection_date; }
  void set_refection_date(int value);

  const QString & refection_note() const { return m_refection_note; }
  void set_refection_note(const QString & value);

  const QString & status() const { return m_status; }
  void set_status(const QString & value);

  const QStringList & topos() const { return m_topos; }
  void set_topos(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_coordinate_modified() const { return bit_status(Schema::Fields::COORDINATE); }
  bool is_colour_modified() const { return bit_status(Schema::Fields::COLOUR); }
  bool is_creation_date_modified() const { return bit_status(Schema::Fields::CREATION_DATE); }
  bool is_gestion_modified() const { return bit_status(Schema::Fields::GESTION); }
  bool is_grade_modified() const { return bit_status(Schema::Fields::GRADE); }
  bool is_massif_id_modified() const { return bit_status(Schema::Fields::MASSIF_ID); }
  bool is_note_modified() const { return bit_status(Schema::Fields::NOTE); }
  bool is_number_modified() const { return bit_status(Schema::Fields::NUMBER); }
  bool is_opener_modified() const { return bit_status(Schema::Fields::OPENER); }
  bool is_refection_date_modified() const { return bit_status(Schema::Fields::REFECTION_DATE); }
  bool is_refection_note_modified() const { return bit_status(Schema::Fields::REFECTION_NOTE); }
  bool is_status_modified() const { return bit_status(Schema::Fields::STATUS); }
  bool is_topos_modified() const { return bit_status(Schema::Fields::TOPOS); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_save() const;

  void load_relations();
  void save_relations();

  QoRowList<BleauBoulder, BleauBoulderPtr> & boulders() { return m_boulders; }
  BleauMassifPtr massif();

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void coordinateChanged();
  void colourChanged();
  void creation_dateChanged();
  void gestionChanged();
  void gradeChanged();
  void massif_idChanged();
  void noteChanged();
  void numberChanged();
  void openerChanged();
  void refection_dateChanged();
  void refection_noteChanged();
  void statusChanged();
  void toposChanged();

private:
  int m_id;
  QGeoCoordinate m_coordinate;
  QString m_colour;
  int m_creation_date;
  QString m_gestion;
  QString m_grade;
  int m_massif_id;
  QString m_note;
  int m_number;
  QString m_opener;
  int m_refection_date;
  QString m_refection_note;
  QString m_status;
  QStringList m_topos;
  QoRowList<BleauBoulder, BleauBoulderPtr> m_boulders;
  BleauMassifPtr m_massif;

};

QDataStream & operator<<(QDataStream & out, const BleauCircuit & obj);
QDataStream & operator>>(QDataStream & in, BleauCircuit & obj);
// qRegisterMetaTypeStreamOperators<BleauCircuit>("BleauCircuit");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauCircuit & obj);
#endif

/**************************************************************************************************/

class BleauCircuitPtr
{
public:
  typedef BleauCircuit Class;

public:
  BleauCircuitPtr() : m_ptr() {}
  BleauCircuitPtr(const BleauCircuitPtr & other) : m_ptr(other.m_ptr) {}
  ~BleauCircuitPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete BleauCircuitPtr of" << *m_ptr;
    // qATInfo() << "--- Delete BleauCircuitPtr";
    // m_ptr.clear();
  }

  BleauCircuitPtr & operator=(const BleauCircuitPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  BleauCircuitPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  BleauCircuitPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  BleauCircuitPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  BleauCircuitPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  BleauCircuitPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  BleauCircuitPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  BleauCircuitPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const BleauCircuitPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API
  void set_massif(BleauMassifPtr & value);

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const BleauCircuitPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauCircuitPtr & obj);
#endif

/**************************************************************************************************/

class BleauCircuitCache : public QObject
{
  Q_OBJECT

public:
  typedef BleauCircuit * t_Key;
  typedef BleauCircuitPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  BleauCircuitCache();
  ~BleauCircuitCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class BleauCircuitModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef BleauCircuitPtr Item;
  typedef QList<Item> ItemList;

public:
  BleauCircuitModel();
  BleauCircuitModel(const ItemList & items);
  ~BleauCircuitModel();

  // Fixme: use BleauCircuitSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    COORDINATE,
    COLOUR,
    CREATION_DATE,
    GESTION,
    GRADE,
    MASSIF_ID,
    NOTE,
    NUMBER,
    OPENER,
    REFECTION_DATE,
    REFECTION_NOTE,
    STATUS,
    TOPOS
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class BleauBoulder;
class BleauBoulderPtr;

/**************************************************************************************************/

class BleauBoulderSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    COORDINATE,
    NAME,
    COMMENT,
    GRADE,
    NUMBER,
    CIRCUIT_ID
  };
  static const int NUMBER_OF_FIELDS = 7;

public:
  static BleauBoulderSchema & instance()
  {
    static BleauBoulderSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  BleauBoulderSchema(const BleauBoulderSchema &) = delete;
  BleauBoulderSchema(BleauBoulderSchema &&) = delete;
  BleauBoulderSchema & operator=(const BleauBoulderSchema &) = delete;
  BleauBoulderSchema & operator=(BleauBoulderSchema &&) = delete;

protected:
  BleauBoulderSchema();
  ~BleauBoulderSchema();
};

/**************************************************************************************************/

class BleauBoulder : public QObject, public QoRow<BleauBoulderSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QGeoCoordinate coordinate READ coordinate WRITE set_coordinate NOTIFY coordinateChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(QString comment READ comment WRITE set_comment NOTIFY commentChanged)
  Q_PROPERTY(QString grade READ grade WRITE set_grade NOTIFY gradeChanged)
  Q_PROPERTY(QString number READ number WRITE set_number NOTIFY numberChanged)
  Q_PROPERTY(int circuit_id READ circuit_id WRITE set_circuit_id NOTIFY circuit_idChanged)

public:
  typedef BleauBoulderPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class BleauBoulderPtr;

public:
  BleauBoulder();
  BleauBoulder(const BleauBoulder & other);
  BleauBoulder(const QJsonObject & json_object); // JSON deserializer
  BleauBoulder(const QVariantHash & variant_hash);
  BleauBoulder(const QVariantList & variants);
  BleauBoulder(const QSqlRecord & record); // SQL deserializer
  BleauBoulder(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~BleauBoulder();

  BleauBoulder & operator=(const BleauBoulder & other);

  bool operator==(const BleauBoulder & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QGeoCoordinate & coordinate() const { return m_coordinate; }
  void set_coordinate(const QGeoCoordinate & value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  const QString & comment() const { return m_comment; }
  void set_comment(const QString & value);

  const QString & grade() const { return m_grade; }
  void set_grade(const QString & value);

  const QString & number() const { return m_number; }
  void set_number(const QString & value);

  int circuit_id() const { return m_circuit_id; }
  void set_circuit_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_coordinate_modified() const { return bit_status(Schema::Fields::COORDINATE); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_comment_modified() const { return bit_status(Schema::Fields::COMMENT); }
  bool is_grade_modified() const { return bit_status(Schema::Fields::GRADE); }
  bool is_number_modified() const { return bit_status(Schema::Fields::NUMBER); }
  bool is_circuit_id_modified() const { return bit_status(Schema::Fields::CIRCUIT_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_save() const;

  void load_relations();
  void save_relations();

  BleauCircuitPtr circuit();

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void coordinateChanged();
  void nameChanged();
  void commentChanged();
  void gradeChanged();
  void numberChanged();
  void circuit_idChanged();

private:
  int m_id;
  QGeoCoordinate m_coordinate;
  QString m_name;
  QString m_comment;
  QString m_grade;
  QString m_number;
  int m_circuit_id;
  BleauCircuitPtr m_circuit;

};

QDataStream & operator<<(QDataStream & out, const BleauBoulder & obj);
QDataStream & operator>>(QDataStream & in, BleauBoulder & obj);
// qRegisterMetaTypeStreamOperators<BleauBoulder>("BleauBoulder");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauBoulder & obj);
#endif

/**************************************************************************************************/

class BleauBoulderPtr
{
public:
  typedef BleauBoulder Class;

public:
  BleauBoulderPtr() : m_ptr() {}
  BleauBoulderPtr(const BleauBoulderPtr & other) : m_ptr(other.m_ptr) {}
  ~BleauBoulderPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete BleauBoulderPtr of" << *m_ptr;
    // qATInfo() << "--- Delete BleauBoulderPtr";
    // m_ptr.clear();
  }

  BleauBoulderPtr & operator=(const BleauBoulderPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  BleauBoulderPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  BleauBoulderPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  BleauBoulderPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  BleauBoulderPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  BleauBoulderPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  BleauBoulderPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  BleauBoulderPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const BleauBoulderPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API
  void set_circuit(BleauCircuitPtr & value);

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const BleauBoulderPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const BleauBoulderPtr & obj);
#endif

/**************************************************************************************************/

class BleauBoulderCache : public QObject
{
  Q_OBJECT

public:
  typedef BleauBoulder * t_Key;
  typedef BleauBoulderPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  BleauBoulderCache();
  ~BleauBoulderCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class BleauBoulderModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef BleauBoulderPtr Item;
  typedef QList<Item> ItemList;

public:
  BleauBoulderModel();
  BleauBoulderModel(const ItemList & items);
  ~BleauBoulderModel();

  // Fixme: use BleauBoulderSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    COORDINATE,
    NAME,
    COMMENT,
    GRADE,
    NUMBER,
    CIRCUIT_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class BleauSchema : public QoDatabaseSchema
{
public:
  BleauSchema(QoDatabase & database);
  BleauSchema(const BleauSchema & other) = delete;
  ~BleauSchema();

  BleauSchema & operator=(const BleauSchema & other) = delete;

  QoDatabaseTable & place() { return *m_place; }
  QoDatabaseTable & massif() { return *m_massif; }
  QoDatabaseTable & circuit() { return *m_circuit; }
  QoDatabaseTable & boulder() { return *m_boulder; }

private:
  template<class T> void register_row(typename T::Ptr & row);

private:
  QoDatabaseTable * m_place;
  QoDatabaseTable * m_massif;
  QoDatabaseTable * m_circuit;
  QoDatabaseTable * m_boulder;
  BleauPlaceCache m_place_cache;
  BleauMassifCache m_massif_cache;
  BleauCircuitCache m_circuit_cache;
  BleauBoulderCache m_boulder_cache;
};

/**************************************************************************************************/
#endif /* __BLEAU_SCHEMA_H__ */