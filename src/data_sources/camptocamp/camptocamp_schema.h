// -*- mode: c++ -*-
// This file was automatically generated by SqlOrm

/***************************************************************************************************
 *
** This file is part of the Alpine Toolkit software.
** Copyright (C) 2017 Fabrice Salvaire
** Contact: http://www.fabrice-salvaire.fr
** SPDX-License-Identifier: GPL-3.0-only
 *
 **************************************************************************************************/

/**************************************************************************************************/

#ifndef __CAMPTOCAMP_SCHEMA_H__
#define __CAMPTOCAMP_SCHEMA_H__

/**************************************************************************************************/

#define QT_SHAREDPOINTER_TRACK_POINTERS // For dubug purpose

#include "alpine_toolkit.h"
#include "orm/database_row.h"
#include "orm/database_row_list.h"
#include "orm/database_schema.h"
#include "orm/schema.h"

#include <QAbstractListModel>
#include <QChar>
#include <QDataStream>
#include <QDate>
#include <QDateTime>
#include <QJsonObject>
#include <QMap>
#include <QSharedPointer>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QString>
#include <QStringList>
#include <QtDebug>
#include <QVariant>
#include <QVariantList>

/**************************************************************************************************/

class C2cAreaAssociations;
class C2cAreaAssociationsPtr;

/**************************************************************************************************/

class C2cAreaAssociationsSchema : public QoSchema
{
public:
  enum Fields {
    AREA_ID,
    DOCUMENT_ID
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static C2cAreaAssociationsSchema & instance()
  {
    static C2cAreaAssociationsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cAreaAssociationsSchema(const C2cAreaAssociationsSchema &) = delete;
  C2cAreaAssociationsSchema(C2cAreaAssociationsSchema &&) = delete;
  C2cAreaAssociationsSchema & operator=(const C2cAreaAssociationsSchema &) = delete;
  C2cAreaAssociationsSchema & operator=(C2cAreaAssociationsSchema &&) = delete;

protected:
  C2cAreaAssociationsSchema();
  ~C2cAreaAssociationsSchema();
};

/**************************************************************************************************/

class C2cAreaAssociations : public QObject, public QoRow<C2cAreaAssociationsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int area_id READ area_id WRITE set_area_id NOTIFY area_idChanged)
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)

public:
  typedef C2cAreaAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cAreaAssociationsPtr;

public:
  C2cAreaAssociations();
  C2cAreaAssociations(const C2cAreaAssociations & other);
  C2cAreaAssociations(const QJsonObject & json_object); // JSON deserializer
  C2cAreaAssociations(const QVariantHash & variant_hash);
  C2cAreaAssociations(const QVariantList & variants);
  C2cAreaAssociations(const QSqlRecord & record); // SQL deserializer
  C2cAreaAssociations(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cAreaAssociations();

  C2cAreaAssociations & operator=(const C2cAreaAssociations & other);

  bool operator==(const C2cAreaAssociations & other) const;

  // Getter/Setter

  int area_id() const { return m_area_id; }
  void set_area_id(int value);

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_area_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_area_id_modified() const { return bit_status(Schema::Fields::AREA_ID); }
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void area_idChanged();
  void document_idChanged();

private:
  int m_area_id;
  int m_document_id;

};

QDataStream & operator<<(QDataStream & out, const C2cAreaAssociations & obj);
QDataStream & operator>>(QDataStream & in, C2cAreaAssociations & obj);
// qRegisterMetaTypeStreamOperators<C2cAreaAssociations>("C2cAreaAssociations");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cAreaAssociations & obj);
#endif

/**************************************************************************************************/

class C2cAreaAssociationsPtr
{
public:
  typedef C2cAreaAssociations Class;

public:
  C2cAreaAssociationsPtr() : m_ptr() {}
  C2cAreaAssociationsPtr(const C2cAreaAssociationsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cAreaAssociationsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cAreaAssociationsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cAreaAssociationsPtr";
    // m_ptr.clear();
  }

  C2cAreaAssociationsPtr & operator=(const C2cAreaAssociationsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cAreaAssociationsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cAreaAssociationsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cAreaAssociationsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cAreaAssociationsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cAreaAssociationsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cAreaAssociationsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cAreaAssociationsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cAreaAssociationsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cAreaAssociationsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cAreaAssociationsPtr & obj);
#endif

/**************************************************************************************************/

class C2cAreaAssociationsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cAreaAssociations * t_Key;
  typedef C2cAreaAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cAreaAssociationsCache();
  ~C2cAreaAssociationsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cAreaAssociationsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cAreaAssociationsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cAreaAssociationsModel();
  C2cAreaAssociationsModel(const ItemList & items);
  ~C2cAreaAssociationsModel();

  // Fixme: use C2cAreaAssociationsSchema::Fields ???
  enum Roles {
    AREA_ID = Qt::UserRole + 1,
    DOCUMENT_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cAreas;
class C2cAreasPtr;

/**************************************************************************************************/

class C2cAreasSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    AREA_TYPE
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static C2cAreasSchema & instance()
  {
    static C2cAreasSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cAreasSchema(const C2cAreasSchema &) = delete;
  C2cAreasSchema(C2cAreasSchema &&) = delete;
  C2cAreasSchema & operator=(const C2cAreasSchema &) = delete;
  C2cAreasSchema & operator=(C2cAreasSchema &&) = delete;

protected:
  C2cAreasSchema();
  ~C2cAreasSchema();
};

/**************************************************************************************************/

class C2cAreas : public QObject, public QoRow<C2cAreasSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString area_type READ area_type WRITE set_area_type NOTIFY area_typeChanged)

public:
  typedef C2cAreasPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cAreasPtr;

public:
  C2cAreas();
  C2cAreas(const C2cAreas & other);
  C2cAreas(const QJsonObject & json_object); // JSON deserializer
  C2cAreas(const QVariantHash & variant_hash);
  C2cAreas(const QVariantList & variants);
  C2cAreas(const QSqlRecord & record); // SQL deserializer
  C2cAreas(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cAreas();

  C2cAreas & operator=(const C2cAreas & other);

  bool operator==(const C2cAreas & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & area_type() const { return m_area_type; }
  void set_area_type(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_area_type_modified() const { return bit_status(Schema::Fields::AREA_TYPE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void area_typeChanged();

private:
  int m_document_id;
  QString m_area_type;

};

QDataStream & operator<<(QDataStream & out, const C2cAreas & obj);
QDataStream & operator>>(QDataStream & in, C2cAreas & obj);
// qRegisterMetaTypeStreamOperators<C2cAreas>("C2cAreas");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cAreas & obj);
#endif

/**************************************************************************************************/

class C2cAreasPtr
{
public:
  typedef C2cAreas Class;

public:
  C2cAreasPtr() : m_ptr() {}
  C2cAreasPtr(const C2cAreasPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cAreasPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cAreasPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cAreasPtr";
    // m_ptr.clear();
  }

  C2cAreasPtr & operator=(const C2cAreasPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cAreasPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cAreasPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cAreasPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cAreasPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cAreasPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cAreasPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cAreasPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cAreasPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cAreasPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cAreasPtr & obj);
#endif

/**************************************************************************************************/

class C2cAreasCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cAreas * t_Key;
  typedef C2cAreasPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cAreasCache();
  ~C2cAreasCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cAreasModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cAreasPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cAreasModel();
  C2cAreasModel(const ItemList & items);
  ~C2cAreasModel();

  // Fixme: use C2cAreasSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    AREA_TYPE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cArticles;
class C2cArticlesPtr;

/**************************************************************************************************/

class C2cArticlesSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    ARTICLE_TYPE,
    CATEGORIES
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static C2cArticlesSchema & instance()
  {
    static C2cArticlesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cArticlesSchema(const C2cArticlesSchema &) = delete;
  C2cArticlesSchema(C2cArticlesSchema &&) = delete;
  C2cArticlesSchema & operator=(const C2cArticlesSchema &) = delete;
  C2cArticlesSchema & operator=(C2cArticlesSchema &&) = delete;

protected:
  C2cArticlesSchema();
  ~C2cArticlesSchema();
};

/**************************************************************************************************/

class C2cArticles : public QObject, public QoRow<C2cArticlesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString article_type READ article_type WRITE set_article_type NOTIFY article_typeChanged)
  Q_PROPERTY(QStringList categories READ categories WRITE set_categories NOTIFY categoriesChanged)

public:
  typedef C2cArticlesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cArticlesPtr;

public:
  C2cArticles();
  C2cArticles(const C2cArticles & other);
  C2cArticles(const QJsonObject & json_object); // JSON deserializer
  C2cArticles(const QVariantHash & variant_hash);
  C2cArticles(const QVariantList & variants);
  C2cArticles(const QSqlRecord & record); // SQL deserializer
  C2cArticles(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cArticles();

  C2cArticles & operator=(const C2cArticles & other);

  bool operator==(const C2cArticles & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & article_type() const { return m_article_type; }
  void set_article_type(const QString & value);

  const QStringList & categories() const { return m_categories; }
  void set_categories(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_article_type_modified() const { return bit_status(Schema::Fields::ARTICLE_TYPE); }
  bool is_categories_modified() const { return bit_status(Schema::Fields::CATEGORIES); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void article_typeChanged();
  void categoriesChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_article_type;
  QStringList m_categories;

};

QDataStream & operator<<(QDataStream & out, const C2cArticles & obj);
QDataStream & operator>>(QDataStream & in, C2cArticles & obj);
// qRegisterMetaTypeStreamOperators<C2cArticles>("C2cArticles");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cArticles & obj);
#endif

/**************************************************************************************************/

class C2cArticlesPtr
{
public:
  typedef C2cArticles Class;

public:
  C2cArticlesPtr() : m_ptr() {}
  C2cArticlesPtr(const C2cArticlesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cArticlesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cArticlesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cArticlesPtr";
    // m_ptr.clear();
  }

  C2cArticlesPtr & operator=(const C2cArticlesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cArticlesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cArticlesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cArticlesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cArticlesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cArticlesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cArticlesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cArticlesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cArticlesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cArticlesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cArticlesPtr & obj);
#endif

/**************************************************************************************************/

class C2cArticlesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cArticles * t_Key;
  typedef C2cArticlesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cArticlesCache();
  ~C2cArticlesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cArticlesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cArticlesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cArticlesModel();
  C2cArticlesModel(const ItemList & items);
  ~C2cArticlesModel();

  // Fixme: use C2cArticlesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    ARTICLE_TYPE,
    CATEGORIES
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cAssociations;
class C2cAssociationsPtr;

/**************************************************************************************************/

class C2cAssociationsSchema : public QoSchema
{
public:
  enum Fields {
    CHILD_DOCUMENT_ID,
    PARENT_DOCUMENT_ID,
    CHILD_DOCUMENT_TYPE,
    PARENT_DOCUMENT_TYPE
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static C2cAssociationsSchema & instance()
  {
    static C2cAssociationsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cAssociationsSchema(const C2cAssociationsSchema &) = delete;
  C2cAssociationsSchema(C2cAssociationsSchema &&) = delete;
  C2cAssociationsSchema & operator=(const C2cAssociationsSchema &) = delete;
  C2cAssociationsSchema & operator=(C2cAssociationsSchema &&) = delete;

protected:
  C2cAssociationsSchema();
  ~C2cAssociationsSchema();
};

/**************************************************************************************************/

class C2cAssociations : public QObject, public QoRow<C2cAssociationsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int child_document_id READ child_document_id WRITE set_child_document_id NOTIFY child_document_idChanged)
  Q_PROPERTY(int parent_document_id READ parent_document_id WRITE set_parent_document_id NOTIFY parent_document_idChanged)
  Q_PROPERTY(QChar child_document_type READ child_document_type WRITE set_child_document_type NOTIFY child_document_typeChanged)
  Q_PROPERTY(QChar parent_document_type READ parent_document_type WRITE set_parent_document_type NOTIFY parent_document_typeChanged)

public:
  typedef C2cAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cAssociationsPtr;

public:
  C2cAssociations();
  C2cAssociations(const C2cAssociations & other);
  C2cAssociations(const QJsonObject & json_object); // JSON deserializer
  C2cAssociations(const QVariantHash & variant_hash);
  C2cAssociations(const QVariantList & variants);
  C2cAssociations(const QSqlRecord & record); // SQL deserializer
  C2cAssociations(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cAssociations();

  C2cAssociations & operator=(const C2cAssociations & other);

  bool operator==(const C2cAssociations & other) const;

  // Getter/Setter

  int child_document_id() const { return m_child_document_id; }
  void set_child_document_id(int value);

  int parent_document_id() const { return m_parent_document_id; }
  void set_parent_document_id(int value);

  const QChar & child_document_type() const { return m_child_document_type; }
  void set_child_document_type(const QChar & value);

  const QChar & parent_document_type() const { return m_parent_document_type; }
  void set_parent_document_type(const QChar & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_child_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_child_document_id_modified() const { return bit_status(Schema::Fields::CHILD_DOCUMENT_ID); }
  bool is_parent_document_id_modified() const { return bit_status(Schema::Fields::PARENT_DOCUMENT_ID); }
  bool is_child_document_type_modified() const { return bit_status(Schema::Fields::CHILD_DOCUMENT_TYPE); }
  bool is_parent_document_type_modified() const { return bit_status(Schema::Fields::PARENT_DOCUMENT_TYPE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void child_document_idChanged();
  void parent_document_idChanged();
  void child_document_typeChanged();
  void parent_document_typeChanged();

private:
  int m_child_document_id;
  int m_parent_document_id;
  QChar m_child_document_type;
  QChar m_parent_document_type;

};

QDataStream & operator<<(QDataStream & out, const C2cAssociations & obj);
QDataStream & operator>>(QDataStream & in, C2cAssociations & obj);
// qRegisterMetaTypeStreamOperators<C2cAssociations>("C2cAssociations");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cAssociations & obj);
#endif

/**************************************************************************************************/

class C2cAssociationsPtr
{
public:
  typedef C2cAssociations Class;

public:
  C2cAssociationsPtr() : m_ptr() {}
  C2cAssociationsPtr(const C2cAssociationsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cAssociationsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cAssociationsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cAssociationsPtr";
    // m_ptr.clear();
  }

  C2cAssociationsPtr & operator=(const C2cAssociationsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cAssociationsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cAssociationsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cAssociationsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cAssociationsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cAssociationsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cAssociationsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cAssociationsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cAssociationsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cAssociationsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cAssociationsPtr & obj);
#endif

/**************************************************************************************************/

class C2cAssociationsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cAssociations * t_Key;
  typedef C2cAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cAssociationsCache();
  ~C2cAssociationsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cAssociationsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cAssociationsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cAssociationsModel();
  C2cAssociationsModel(const ItemList & items);
  ~C2cAssociationsModel();

  // Fixme: use C2cAssociationsSchema::Fields ???
  enum Roles {
    CHILD_DOCUMENT_ID = Qt::UserRole + 1,
    PARENT_DOCUMENT_ID,
    CHILD_DOCUMENT_TYPE,
    PARENT_DOCUMENT_TYPE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cBooks;
class C2cBooksPtr;

/**************************************************************************************************/

class C2cBooksSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    AUTHOR,
    BOOK_TYPES,
    EDITOR,
    ISBN,
    LANGS,
    NB_PAGES,
    PUBLICATION_DATE,
    URL
  };
  static const int NUMBER_OF_FIELDS = 10;

public:
  static C2cBooksSchema & instance()
  {
    static C2cBooksSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cBooksSchema(const C2cBooksSchema &) = delete;
  C2cBooksSchema(C2cBooksSchema &&) = delete;
  C2cBooksSchema & operator=(const C2cBooksSchema &) = delete;
  C2cBooksSchema & operator=(C2cBooksSchema &&) = delete;

protected:
  C2cBooksSchema();
  ~C2cBooksSchema();
};

/**************************************************************************************************/

class C2cBooks : public QObject, public QoRow<C2cBooksSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString author READ author WRITE set_author NOTIFY authorChanged)
  Q_PROPERTY(QStringList book_types READ book_types WRITE set_book_types NOTIFY book_typesChanged)
  Q_PROPERTY(QString editor READ editor WRITE set_editor NOTIFY editorChanged)
  Q_PROPERTY(QString isbn READ isbn WRITE set_isbn NOTIFY isbnChanged)
  Q_PROPERTY(QStringList langs READ langs WRITE set_langs NOTIFY langsChanged)
  Q_PROPERTY(int nb_pages READ nb_pages WRITE set_nb_pages NOTIFY nb_pagesChanged)
  Q_PROPERTY(QString publication_date READ publication_date WRITE set_publication_date NOTIFY publication_dateChanged)
  Q_PROPERTY(QString url READ url WRITE set_url NOTIFY urlChanged)

public:
  typedef C2cBooksPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cBooksPtr;

public:
  C2cBooks();
  C2cBooks(const C2cBooks & other);
  C2cBooks(const QJsonObject & json_object); // JSON deserializer
  C2cBooks(const QVariantHash & variant_hash);
  C2cBooks(const QVariantList & variants);
  C2cBooks(const QSqlRecord & record); // SQL deserializer
  C2cBooks(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cBooks();

  C2cBooks & operator=(const C2cBooks & other);

  bool operator==(const C2cBooks & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & author() const { return m_author; }
  void set_author(const QString & value);

  const QStringList & book_types() const { return m_book_types; }
  void set_book_types(const QStringList & value);

  const QString & editor() const { return m_editor; }
  void set_editor(const QString & value);

  const QString & isbn() const { return m_isbn; }
  void set_isbn(const QString & value);

  const QStringList & langs() const { return m_langs; }
  void set_langs(const QStringList & value);

  int nb_pages() const { return m_nb_pages; }
  void set_nb_pages(int value);

  const QString & publication_date() const { return m_publication_date; }
  void set_publication_date(const QString & value);

  const QString & url() const { return m_url; }
  void set_url(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_author_modified() const { return bit_status(Schema::Fields::AUTHOR); }
  bool is_book_types_modified() const { return bit_status(Schema::Fields::BOOK_TYPES); }
  bool is_editor_modified() const { return bit_status(Schema::Fields::EDITOR); }
  bool is_isbn_modified() const { return bit_status(Schema::Fields::ISBN); }
  bool is_langs_modified() const { return bit_status(Schema::Fields::LANGS); }
  bool is_nb_pages_modified() const { return bit_status(Schema::Fields::NB_PAGES); }
  bool is_publication_date_modified() const { return bit_status(Schema::Fields::PUBLICATION_DATE); }
  bool is_url_modified() const { return bit_status(Schema::Fields::URL); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void authorChanged();
  void book_typesChanged();
  void editorChanged();
  void isbnChanged();
  void langsChanged();
  void nb_pagesChanged();
  void publication_dateChanged();
  void urlChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_author;
  QStringList m_book_types;
  QString m_editor;
  QString m_isbn;
  QStringList m_langs;
  int m_nb_pages;
  QString m_publication_date;
  QString m_url;

};

QDataStream & operator<<(QDataStream & out, const C2cBooks & obj);
QDataStream & operator>>(QDataStream & in, C2cBooks & obj);
// qRegisterMetaTypeStreamOperators<C2cBooks>("C2cBooks");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cBooks & obj);
#endif

/**************************************************************************************************/

class C2cBooksPtr
{
public:
  typedef C2cBooks Class;

public:
  C2cBooksPtr() : m_ptr() {}
  C2cBooksPtr(const C2cBooksPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cBooksPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cBooksPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cBooksPtr";
    // m_ptr.clear();
  }

  C2cBooksPtr & operator=(const C2cBooksPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cBooksPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cBooksPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cBooksPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cBooksPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cBooksPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cBooksPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cBooksPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cBooksPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cBooksPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cBooksPtr & obj);
#endif

/**************************************************************************************************/

class C2cBooksCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cBooks * t_Key;
  typedef C2cBooksPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cBooksCache();
  ~C2cBooksCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cBooksModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cBooksPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cBooksModel();
  C2cBooksModel(const ItemList & items);
  ~C2cBooksModel();

  // Fixme: use C2cBooksSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    AUTHOR,
    BOOK_TYPES,
    EDITOR,
    ISBN,
    LANGS,
    NB_PAGES,
    PUBLICATION_DATE,
    URL
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cDocuments;
class C2cDocumentsPtr;

/**************************************************************************************************/

class C2cDocumentsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    PROTECTED_FLAG,
    QUALITY,
    REDIRECTS_TO,
    TYPE,
    VERSION
  };
  static const int NUMBER_OF_FIELDS = 6;

public:
  static C2cDocumentsSchema & instance()
  {
    static C2cDocumentsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cDocumentsSchema(const C2cDocumentsSchema &) = delete;
  C2cDocumentsSchema(C2cDocumentsSchema &&) = delete;
  C2cDocumentsSchema & operator=(const C2cDocumentsSchema &) = delete;
  C2cDocumentsSchema & operator=(C2cDocumentsSchema &&) = delete;

protected:
  C2cDocumentsSchema();
  ~C2cDocumentsSchema();
};

/**************************************************************************************************/

class C2cDocuments : public QObject, public QoRow<C2cDocumentsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(bool protected_flag READ protected_flag WRITE set_protected_flag NOTIFY protected_flagChanged)
  Q_PROPERTY(QString quality READ quality WRITE set_quality NOTIFY qualityChanged)
  Q_PROPERTY(int redirects_to READ redirects_to WRITE set_redirects_to NOTIFY redirects_toChanged)
  Q_PROPERTY(QChar type READ type WRITE set_type NOTIFY typeChanged)
  Q_PROPERTY(int version READ version WRITE set_version NOTIFY versionChanged)

public:
  typedef C2cDocumentsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cDocumentsPtr;

public:
  C2cDocuments();
  C2cDocuments(const C2cDocuments & other);
  C2cDocuments(const QJsonObject & json_object); // JSON deserializer
  C2cDocuments(const QVariantHash & variant_hash);
  C2cDocuments(const QVariantList & variants);
  C2cDocuments(const QSqlRecord & record); // SQL deserializer
  C2cDocuments(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cDocuments();

  C2cDocuments & operator=(const C2cDocuments & other);

  bool operator==(const C2cDocuments & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  bool protected_flag() const { return m_protected_flag; }
  void set_protected_flag(bool value);

  const QString & quality() const { return m_quality; }
  void set_quality(const QString & value);

  int redirects_to() const { return m_redirects_to; }
  void set_redirects_to(int value);

  const QChar & type() const { return m_type; }
  void set_type(const QChar & value);

  int version() const { return m_version; }
  void set_version(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_protected_flag_modified() const { return bit_status(Schema::Fields::PROTECTED_FLAG); }
  bool is_quality_modified() const { return bit_status(Schema::Fields::QUALITY); }
  bool is_redirects_to_modified() const { return bit_status(Schema::Fields::REDIRECTS_TO); }
  bool is_type_modified() const { return bit_status(Schema::Fields::TYPE); }
  bool is_version_modified() const { return bit_status(Schema::Fields::VERSION); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void protected_flagChanged();
  void qualityChanged();
  void redirects_toChanged();
  void typeChanged();
  void versionChanged();

private:
  int m_document_id;
  bool m_protected_flag;
  QString m_quality;
  int m_redirects_to;
  QChar m_type;
  int m_version;

};

QDataStream & operator<<(QDataStream & out, const C2cDocuments & obj);
QDataStream & operator>>(QDataStream & in, C2cDocuments & obj);
// qRegisterMetaTypeStreamOperators<C2cDocuments>("C2cDocuments");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocuments & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsPtr
{
public:
  typedef C2cDocuments Class;

public:
  C2cDocumentsPtr() : m_ptr() {}
  C2cDocumentsPtr(const C2cDocumentsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cDocumentsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cDocumentsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cDocumentsPtr";
    // m_ptr.clear();
  }

  C2cDocumentsPtr & operator=(const C2cDocumentsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cDocumentsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cDocumentsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cDocumentsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cDocumentsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cDocumentsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cDocumentsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cDocumentsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cDocumentsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cDocumentsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsPtr & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cDocuments * t_Key;
  typedef C2cDocumentsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cDocumentsCache();
  ~C2cDocumentsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cDocumentsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cDocumentsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cDocumentsModel();
  C2cDocumentsModel(const ItemList & items);
  ~C2cDocumentsModel();

  // Fixme: use C2cDocumentsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    PROTECTED_FLAG,
    QUALITY,
    REDIRECTS_TO,
    TYPE,
    VERSION
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cDocumentsGeometries;
class C2cDocumentsGeometriesPtr;

/**************************************************************************************************/

class C2cDocumentsGeometriesSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    GEOM,
    GEOM_DETAIL,
    VERSION
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static C2cDocumentsGeometriesSchema & instance()
  {
    static C2cDocumentsGeometriesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cDocumentsGeometriesSchema(const C2cDocumentsGeometriesSchema &) = delete;
  C2cDocumentsGeometriesSchema(C2cDocumentsGeometriesSchema &&) = delete;
  C2cDocumentsGeometriesSchema & operator=(const C2cDocumentsGeometriesSchema &) = delete;
  C2cDocumentsGeometriesSchema & operator=(C2cDocumentsGeometriesSchema &&) = delete;

protected:
  C2cDocumentsGeometriesSchema();
  ~C2cDocumentsGeometriesSchema();
};

/**************************************************************************************************/

class C2cDocumentsGeometries : public QObject, public QoRow<C2cDocumentsGeometriesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString geom READ geom WRITE set_geom NOTIFY geomChanged)
  Q_PROPERTY(QString geom_detail READ geom_detail WRITE set_geom_detail NOTIFY geom_detailChanged)
  Q_PROPERTY(int version READ version WRITE set_version NOTIFY versionChanged)

public:
  typedef C2cDocumentsGeometriesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cDocumentsGeometriesPtr;

public:
  C2cDocumentsGeometries();
  C2cDocumentsGeometries(const C2cDocumentsGeometries & other);
  C2cDocumentsGeometries(const QJsonObject & json_object); // JSON deserializer
  C2cDocumentsGeometries(const QVariantHash & variant_hash);
  C2cDocumentsGeometries(const QVariantList & variants);
  C2cDocumentsGeometries(const QSqlRecord & record); // SQL deserializer
  C2cDocumentsGeometries(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cDocumentsGeometries();

  C2cDocumentsGeometries & operator=(const C2cDocumentsGeometries & other);

  bool operator==(const C2cDocumentsGeometries & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & geom() const { return m_geom; }
  void set_geom(const QString & value);

  const QString & geom_detail() const { return m_geom_detail; }
  void set_geom_detail(const QString & value);

  int version() const { return m_version; }
  void set_version(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_geom_modified() const { return bit_status(Schema::Fields::GEOM); }
  bool is_geom_detail_modified() const { return bit_status(Schema::Fields::GEOM_DETAIL); }
  bool is_version_modified() const { return bit_status(Schema::Fields::VERSION); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void geomChanged();
  void geom_detailChanged();
  void versionChanged();

private:
  int m_document_id;
  QString m_geom;
  QString m_geom_detail;
  int m_version;

};

QDataStream & operator<<(QDataStream & out, const C2cDocumentsGeometries & obj);
QDataStream & operator>>(QDataStream & in, C2cDocumentsGeometries & obj);
// qRegisterMetaTypeStreamOperators<C2cDocumentsGeometries>("C2cDocumentsGeometries");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsGeometries & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsGeometriesPtr
{
public:
  typedef C2cDocumentsGeometries Class;

public:
  C2cDocumentsGeometriesPtr() : m_ptr() {}
  C2cDocumentsGeometriesPtr(const C2cDocumentsGeometriesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cDocumentsGeometriesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cDocumentsGeometriesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cDocumentsGeometriesPtr";
    // m_ptr.clear();
  }

  C2cDocumentsGeometriesPtr & operator=(const C2cDocumentsGeometriesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cDocumentsGeometriesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cDocumentsGeometriesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cDocumentsGeometriesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cDocumentsGeometriesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cDocumentsGeometriesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cDocumentsGeometriesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cDocumentsGeometriesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cDocumentsGeometriesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cDocumentsGeometriesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsGeometriesPtr & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsGeometriesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cDocumentsGeometries * t_Key;
  typedef C2cDocumentsGeometriesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cDocumentsGeometriesCache();
  ~C2cDocumentsGeometriesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cDocumentsGeometriesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cDocumentsGeometriesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cDocumentsGeometriesModel();
  C2cDocumentsGeometriesModel(const ItemList & items);
  ~C2cDocumentsGeometriesModel();

  // Fixme: use C2cDocumentsGeometriesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    GEOM,
    GEOM_DETAIL,
    VERSION
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cDocumentsLocales;
class C2cDocumentsLocalesPtr;

/**************************************************************************************************/

class C2cDocumentsLocalesSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    DESCRIPTION,
    DOCUMENT_ID,
    LANG,
    SUMMARY,
    TITLE,
    TYPE,
    VERSION
  };
  static const int NUMBER_OF_FIELDS = 8;

public:
  static C2cDocumentsLocalesSchema & instance()
  {
    static C2cDocumentsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cDocumentsLocalesSchema(const C2cDocumentsLocalesSchema &) = delete;
  C2cDocumentsLocalesSchema(C2cDocumentsLocalesSchema &&) = delete;
  C2cDocumentsLocalesSchema & operator=(const C2cDocumentsLocalesSchema &) = delete;
  C2cDocumentsLocalesSchema & operator=(C2cDocumentsLocalesSchema &&) = delete;

protected:
  C2cDocumentsLocalesSchema();
  ~C2cDocumentsLocalesSchema();
};

/**************************************************************************************************/

class C2cDocumentsLocales : public QObject, public QoRow<C2cDocumentsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString description READ description WRITE set_description NOTIFY descriptionChanged)
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString lang READ lang WRITE set_lang NOTIFY langChanged)
  Q_PROPERTY(QString summary READ summary WRITE set_summary NOTIFY summaryChanged)
  Q_PROPERTY(QString title READ title WRITE set_title NOTIFY titleChanged)
  Q_PROPERTY(QChar type READ type WRITE set_type NOTIFY typeChanged)
  Q_PROPERTY(int version READ version WRITE set_version NOTIFY versionChanged)

public:
  typedef C2cDocumentsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cDocumentsLocalesPtr;

public:
  C2cDocumentsLocales();
  C2cDocumentsLocales(const C2cDocumentsLocales & other);
  C2cDocumentsLocales(const QJsonObject & json_object); // JSON deserializer
  C2cDocumentsLocales(const QVariantHash & variant_hash);
  C2cDocumentsLocales(const QVariantList & variants);
  C2cDocumentsLocales(const QSqlRecord & record); // SQL deserializer
  C2cDocumentsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cDocumentsLocales();

  C2cDocumentsLocales & operator=(const C2cDocumentsLocales & other);

  bool operator==(const C2cDocumentsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & description() const { return m_description; }
  void set_description(const QString & value);

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & lang() const { return m_lang; }
  void set_lang(const QString & value);

  const QString & summary() const { return m_summary; }
  void set_summary(const QString & value);

  const QString & title() const { return m_title; }
  void set_title(const QString & value);

  const QChar & type() const { return m_type; }
  void set_type(const QChar & value);

  int version() const { return m_version; }
  void set_version(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_description_modified() const { return bit_status(Schema::Fields::DESCRIPTION); }
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_lang_modified() const { return bit_status(Schema::Fields::LANG); }
  bool is_summary_modified() const { return bit_status(Schema::Fields::SUMMARY); }
  bool is_title_modified() const { return bit_status(Schema::Fields::TITLE); }
  bool is_type_modified() const { return bit_status(Schema::Fields::TYPE); }
  bool is_version_modified() const { return bit_status(Schema::Fields::VERSION); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void descriptionChanged();
  void document_idChanged();
  void langChanged();
  void summaryChanged();
  void titleChanged();
  void typeChanged();
  void versionChanged();

private:
  int m_id;
  QString m_description;
  int m_document_id;
  QString m_lang;
  QString m_summary;
  QString m_title;
  QChar m_type;
  int m_version;

};

QDataStream & operator<<(QDataStream & out, const C2cDocumentsLocales & obj);
QDataStream & operator>>(QDataStream & in, C2cDocumentsLocales & obj);
// qRegisterMetaTypeStreamOperators<C2cDocumentsLocales>("C2cDocumentsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsLocales & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsLocalesPtr
{
public:
  typedef C2cDocumentsLocales Class;

public:
  C2cDocumentsLocalesPtr() : m_ptr() {}
  C2cDocumentsLocalesPtr(const C2cDocumentsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cDocumentsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cDocumentsLocalesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cDocumentsLocalesPtr";
    // m_ptr.clear();
  }

  C2cDocumentsLocalesPtr & operator=(const C2cDocumentsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cDocumentsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cDocumentsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cDocumentsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cDocumentsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cDocumentsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cDocumentsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cDocumentsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cDocumentsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cDocumentsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cDocumentsLocales * t_Key;
  typedef C2cDocumentsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cDocumentsLocalesCache();
  ~C2cDocumentsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cDocumentsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cDocumentsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cDocumentsLocalesModel();
  C2cDocumentsLocalesModel(const ItemList & items);
  ~C2cDocumentsLocalesModel();

  // Fixme: use C2cDocumentsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    DESCRIPTION,
    DOCUMENT_ID,
    LANG,
    SUMMARY,
    TITLE,
    TYPE,
    VERSION
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cDocumentsTopics;
class C2cDocumentsTopicsPtr;

/**************************************************************************************************/

class C2cDocumentsTopicsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_LOCALE_ID,
    TOPIC_ID
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static C2cDocumentsTopicsSchema & instance()
  {
    static C2cDocumentsTopicsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cDocumentsTopicsSchema(const C2cDocumentsTopicsSchema &) = delete;
  C2cDocumentsTopicsSchema(C2cDocumentsTopicsSchema &&) = delete;
  C2cDocumentsTopicsSchema & operator=(const C2cDocumentsTopicsSchema &) = delete;
  C2cDocumentsTopicsSchema & operator=(C2cDocumentsTopicsSchema &&) = delete;

protected:
  C2cDocumentsTopicsSchema();
  ~C2cDocumentsTopicsSchema();
};

/**************************************************************************************************/

class C2cDocumentsTopics : public QObject, public QoRow<C2cDocumentsTopicsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_locale_id READ document_locale_id WRITE set_document_locale_id NOTIFY document_locale_idChanged)
  Q_PROPERTY(int topic_id READ topic_id WRITE set_topic_id NOTIFY topic_idChanged)

public:
  typedef C2cDocumentsTopicsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cDocumentsTopicsPtr;

public:
  C2cDocumentsTopics();
  C2cDocumentsTopics(const C2cDocumentsTopics & other);
  C2cDocumentsTopics(const QJsonObject & json_object); // JSON deserializer
  C2cDocumentsTopics(const QVariantHash & variant_hash);
  C2cDocumentsTopics(const QVariantList & variants);
  C2cDocumentsTopics(const QSqlRecord & record); // SQL deserializer
  C2cDocumentsTopics(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cDocumentsTopics();

  C2cDocumentsTopics & operator=(const C2cDocumentsTopics & other);

  bool operator==(const C2cDocumentsTopics & other) const;

  // Getter/Setter

  int document_locale_id() const { return m_document_locale_id; }
  void set_document_locale_id(int value);

  int topic_id() const { return m_topic_id; }
  void set_topic_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_locale_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_locale_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_LOCALE_ID); }
  bool is_topic_id_modified() const { return bit_status(Schema::Fields::TOPIC_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_locale_idChanged();
  void topic_idChanged();

private:
  int m_document_locale_id;
  int m_topic_id;

};

QDataStream & operator<<(QDataStream & out, const C2cDocumentsTopics & obj);
QDataStream & operator>>(QDataStream & in, C2cDocumentsTopics & obj);
// qRegisterMetaTypeStreamOperators<C2cDocumentsTopics>("C2cDocumentsTopics");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsTopics & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsTopicsPtr
{
public:
  typedef C2cDocumentsTopics Class;

public:
  C2cDocumentsTopicsPtr() : m_ptr() {}
  C2cDocumentsTopicsPtr(const C2cDocumentsTopicsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cDocumentsTopicsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cDocumentsTopicsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cDocumentsTopicsPtr";
    // m_ptr.clear();
  }

  C2cDocumentsTopicsPtr & operator=(const C2cDocumentsTopicsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cDocumentsTopicsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cDocumentsTopicsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cDocumentsTopicsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cDocumentsTopicsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cDocumentsTopicsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cDocumentsTopicsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cDocumentsTopicsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cDocumentsTopicsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cDocumentsTopicsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsTopicsPtr & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsTopicsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cDocumentsTopics * t_Key;
  typedef C2cDocumentsTopicsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cDocumentsTopicsCache();
  ~C2cDocumentsTopicsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cDocumentsTopicsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cDocumentsTopicsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cDocumentsTopicsModel();
  C2cDocumentsTopicsModel(const ItemList & items);
  ~C2cDocumentsTopicsModel();

  // Fixme: use C2cDocumentsTopicsSchema::Fields ???
  enum Roles {
    DOCUMENT_LOCALE_ID = Qt::UserRole + 1,
    TOPIC_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cDocumentsVersions;
class C2cDocumentsVersionsPtr;

/**************************************************************************************************/

class C2cDocumentsVersionsSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    DOCUMENT_ARCHIVE_ID,
    DOCUMENT_GEOMETRY_ARCHIVE_ID,
    DOCUMENT_ID,
    DOCUMENT_LOCALES_ARCHIVE_ID,
    HISTORY_METADATA_ID,
    LANG
  };
  static const int NUMBER_OF_FIELDS = 7;

public:
  static C2cDocumentsVersionsSchema & instance()
  {
    static C2cDocumentsVersionsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cDocumentsVersionsSchema(const C2cDocumentsVersionsSchema &) = delete;
  C2cDocumentsVersionsSchema(C2cDocumentsVersionsSchema &&) = delete;
  C2cDocumentsVersionsSchema & operator=(const C2cDocumentsVersionsSchema &) = delete;
  C2cDocumentsVersionsSchema & operator=(C2cDocumentsVersionsSchema &&) = delete;

protected:
  C2cDocumentsVersionsSchema();
  ~C2cDocumentsVersionsSchema();
};

/**************************************************************************************************/

class C2cDocumentsVersions : public QObject, public QoRow<C2cDocumentsVersionsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(int document_archive_id READ document_archive_id WRITE set_document_archive_id NOTIFY document_archive_idChanged)
  Q_PROPERTY(int document_geometry_archive_id READ document_geometry_archive_id WRITE set_document_geometry_archive_id NOTIFY document_geometry_archive_idChanged)
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(int document_locales_archive_id READ document_locales_archive_id WRITE set_document_locales_archive_id NOTIFY document_locales_archive_idChanged)
  Q_PROPERTY(int history_metadata_id READ history_metadata_id WRITE set_history_metadata_id NOTIFY history_metadata_idChanged)
  Q_PROPERTY(QString lang READ lang WRITE set_lang NOTIFY langChanged)

public:
  typedef C2cDocumentsVersionsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cDocumentsVersionsPtr;

public:
  C2cDocumentsVersions();
  C2cDocumentsVersions(const C2cDocumentsVersions & other);
  C2cDocumentsVersions(const QJsonObject & json_object); // JSON deserializer
  C2cDocumentsVersions(const QVariantHash & variant_hash);
  C2cDocumentsVersions(const QVariantList & variants);
  C2cDocumentsVersions(const QSqlRecord & record); // SQL deserializer
  C2cDocumentsVersions(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cDocumentsVersions();

  C2cDocumentsVersions & operator=(const C2cDocumentsVersions & other);

  bool operator==(const C2cDocumentsVersions & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  int document_archive_id() const { return m_document_archive_id; }
  void set_document_archive_id(int value);

  int document_geometry_archive_id() const { return m_document_geometry_archive_id; }
  void set_document_geometry_archive_id(int value);

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  int document_locales_archive_id() const { return m_document_locales_archive_id; }
  void set_document_locales_archive_id(int value);

  int history_metadata_id() const { return m_history_metadata_id; }
  void set_history_metadata_id(int value);

  const QString & lang() const { return m_lang; }
  void set_lang(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_document_archive_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ARCHIVE_ID); }
  bool is_document_geometry_archive_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_GEOMETRY_ARCHIVE_ID); }
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_document_locales_archive_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_LOCALES_ARCHIVE_ID); }
  bool is_history_metadata_id_modified() const { return bit_status(Schema::Fields::HISTORY_METADATA_ID); }
  bool is_lang_modified() const { return bit_status(Schema::Fields::LANG); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void document_archive_idChanged();
  void document_geometry_archive_idChanged();
  void document_idChanged();
  void document_locales_archive_idChanged();
  void history_metadata_idChanged();
  void langChanged();

private:
  int m_id;
  int m_document_archive_id;
  int m_document_geometry_archive_id;
  int m_document_id;
  int m_document_locales_archive_id;
  int m_history_metadata_id;
  QString m_lang;

};

QDataStream & operator<<(QDataStream & out, const C2cDocumentsVersions & obj);
QDataStream & operator>>(QDataStream & in, C2cDocumentsVersions & obj);
// qRegisterMetaTypeStreamOperators<C2cDocumentsVersions>("C2cDocumentsVersions");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsVersions & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsVersionsPtr
{
public:
  typedef C2cDocumentsVersions Class;

public:
  C2cDocumentsVersionsPtr() : m_ptr() {}
  C2cDocumentsVersionsPtr(const C2cDocumentsVersionsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cDocumentsVersionsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cDocumentsVersionsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cDocumentsVersionsPtr";
    // m_ptr.clear();
  }

  C2cDocumentsVersionsPtr & operator=(const C2cDocumentsVersionsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cDocumentsVersionsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cDocumentsVersionsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cDocumentsVersionsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cDocumentsVersionsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cDocumentsVersionsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cDocumentsVersionsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cDocumentsVersionsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cDocumentsVersionsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cDocumentsVersionsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cDocumentsVersionsPtr & obj);
#endif

/**************************************************************************************************/

class C2cDocumentsVersionsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cDocumentsVersions * t_Key;
  typedef C2cDocumentsVersionsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cDocumentsVersionsCache();
  ~C2cDocumentsVersionsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cDocumentsVersionsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cDocumentsVersionsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cDocumentsVersionsModel();
  C2cDocumentsVersionsModel(const ItemList & items);
  ~C2cDocumentsVersionsModel();

  // Fixme: use C2cDocumentsVersionsSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    DOCUMENT_ARCHIVE_ID,
    DOCUMENT_GEOMETRY_ARCHIVE_ID,
    DOCUMENT_ID,
    DOCUMENT_LOCALES_ARCHIVE_ID,
    HISTORY_METADATA_ID,
    LANG
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cImages;
class C2cImagesPtr;

/**************************************************************************************************/

class C2cImagesSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    AUTHOR,
    CAMERA_NAME,
    CATEGORIES,
    DATE_TIME,
    ELEVATION,
    EXPOSURE_TIME,
    FILE_SIZE,
    FILENAME,
    FNUMBER,
    FOCAL_LENGTH,
    HEIGHT,
    IMAGE_TYPE,
    ISO_SPEED,
    WIDTH
  };
  static const int NUMBER_OF_FIELDS = 16;

public:
  static C2cImagesSchema & instance()
  {
    static C2cImagesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cImagesSchema(const C2cImagesSchema &) = delete;
  C2cImagesSchema(C2cImagesSchema &&) = delete;
  C2cImagesSchema & operator=(const C2cImagesSchema &) = delete;
  C2cImagesSchema & operator=(C2cImagesSchema &&) = delete;

protected:
  C2cImagesSchema();
  ~C2cImagesSchema();
};

/**************************************************************************************************/

class C2cImages : public QObject, public QoRow<C2cImagesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString author READ author WRITE set_author NOTIFY authorChanged)
  Q_PROPERTY(QString camera_name READ camera_name WRITE set_camera_name NOTIFY camera_nameChanged)
  Q_PROPERTY(QStringList categories READ categories WRITE set_categories NOTIFY categoriesChanged)
  Q_PROPERTY(QDateTime date_time READ date_time WRITE set_date_time NOTIFY date_timeChanged)
  Q_PROPERTY(int elevation READ elevation WRITE set_elevation NOTIFY elevationChanged)
  Q_PROPERTY(qreal exposure_time READ exposure_time WRITE set_exposure_time NOTIFY exposure_timeChanged)
  Q_PROPERTY(int file_size READ file_size WRITE set_file_size NOTIFY file_sizeChanged)
  Q_PROPERTY(QString filename READ filename WRITE set_filename NOTIFY filenameChanged)
  Q_PROPERTY(qreal fnumber READ fnumber WRITE set_fnumber NOTIFY fnumberChanged)
  Q_PROPERTY(qreal focal_length READ focal_length WRITE set_focal_length NOTIFY focal_lengthChanged)
  Q_PROPERTY(int height READ height WRITE set_height NOTIFY heightChanged)
  Q_PROPERTY(QString image_type READ image_type WRITE set_image_type NOTIFY image_typeChanged)
  Q_PROPERTY(int iso_speed READ iso_speed WRITE set_iso_speed NOTIFY iso_speedChanged)
  Q_PROPERTY(int width READ width WRITE set_width NOTIFY widthChanged)

public:
  typedef C2cImagesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cImagesPtr;

public:
  C2cImages();
  C2cImages(const C2cImages & other);
  C2cImages(const QJsonObject & json_object); // JSON deserializer
  C2cImages(const QVariantHash & variant_hash);
  C2cImages(const QVariantList & variants);
  C2cImages(const QSqlRecord & record); // SQL deserializer
  C2cImages(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cImages();

  C2cImages & operator=(const C2cImages & other);

  bool operator==(const C2cImages & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & author() const { return m_author; }
  void set_author(const QString & value);

  const QString & camera_name() const { return m_camera_name; }
  void set_camera_name(const QString & value);

  const QStringList & categories() const { return m_categories; }
  void set_categories(const QStringList & value);

  const QDateTime & date_time() const { return m_date_time; }
  void set_date_time(const QDateTime & value);

  int elevation() const { return m_elevation; }
  void set_elevation(int value);

  qreal exposure_time() const { return m_exposure_time; }
  void set_exposure_time(qreal value);

  int file_size() const { return m_file_size; }
  void set_file_size(int value);

  const QString & filename() const { return m_filename; }
  void set_filename(const QString & value);

  qreal fnumber() const { return m_fnumber; }
  void set_fnumber(qreal value);

  qreal focal_length() const { return m_focal_length; }
  void set_focal_length(qreal value);

  int height() const { return m_height; }
  void set_height(int value);

  const QString & image_type() const { return m_image_type; }
  void set_image_type(const QString & value);

  int iso_speed() const { return m_iso_speed; }
  void set_iso_speed(int value);

  int width() const { return m_width; }
  void set_width(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_author_modified() const { return bit_status(Schema::Fields::AUTHOR); }
  bool is_camera_name_modified() const { return bit_status(Schema::Fields::CAMERA_NAME); }
  bool is_categories_modified() const { return bit_status(Schema::Fields::CATEGORIES); }
  bool is_date_time_modified() const { return bit_status(Schema::Fields::DATE_TIME); }
  bool is_elevation_modified() const { return bit_status(Schema::Fields::ELEVATION); }
  bool is_exposure_time_modified() const { return bit_status(Schema::Fields::EXPOSURE_TIME); }
  bool is_file_size_modified() const { return bit_status(Schema::Fields::FILE_SIZE); }
  bool is_filename_modified() const { return bit_status(Schema::Fields::FILENAME); }
  bool is_fnumber_modified() const { return bit_status(Schema::Fields::FNUMBER); }
  bool is_focal_length_modified() const { return bit_status(Schema::Fields::FOCAL_LENGTH); }
  bool is_height_modified() const { return bit_status(Schema::Fields::HEIGHT); }
  bool is_image_type_modified() const { return bit_status(Schema::Fields::IMAGE_TYPE); }
  bool is_iso_speed_modified() const { return bit_status(Schema::Fields::ISO_SPEED); }
  bool is_width_modified() const { return bit_status(Schema::Fields::WIDTH); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void authorChanged();
  void camera_nameChanged();
  void categoriesChanged();
  void date_timeChanged();
  void elevationChanged();
  void exposure_timeChanged();
  void file_sizeChanged();
  void filenameChanged();
  void fnumberChanged();
  void focal_lengthChanged();
  void heightChanged();
  void image_typeChanged();
  void iso_speedChanged();
  void widthChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_author;
  QString m_camera_name;
  QStringList m_categories;
  QDateTime m_date_time;
  int m_elevation;
  qreal m_exposure_time;
  int m_file_size;
  QString m_filename;
  qreal m_fnumber;
  qreal m_focal_length;
  int m_height;
  QString m_image_type;
  int m_iso_speed;
  int m_width;

};

QDataStream & operator<<(QDataStream & out, const C2cImages & obj);
QDataStream & operator>>(QDataStream & in, C2cImages & obj);
// qRegisterMetaTypeStreamOperators<C2cImages>("C2cImages");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cImages & obj);
#endif

/**************************************************************************************************/

class C2cImagesPtr
{
public:
  typedef C2cImages Class;

public:
  C2cImagesPtr() : m_ptr() {}
  C2cImagesPtr(const C2cImagesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cImagesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cImagesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cImagesPtr";
    // m_ptr.clear();
  }

  C2cImagesPtr & operator=(const C2cImagesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cImagesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cImagesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cImagesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cImagesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cImagesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cImagesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cImagesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cImagesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cImagesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cImagesPtr & obj);
#endif

/**************************************************************************************************/

class C2cImagesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cImages * t_Key;
  typedef C2cImagesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cImagesCache();
  ~C2cImagesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cImagesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cImagesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cImagesModel();
  C2cImagesModel(const ItemList & items);
  ~C2cImagesModel();

  // Fixme: use C2cImagesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    AUTHOR,
    CAMERA_NAME,
    CATEGORIES,
    DATE_TIME,
    ELEVATION,
    EXPOSURE_TIME,
    FILE_SIZE,
    FILENAME,
    FNUMBER,
    FOCAL_LENGTH,
    HEIGHT,
    IMAGE_TYPE,
    ISO_SPEED,
    WIDTH
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cMapAssociations;
class C2cMapAssociationsPtr;

/**************************************************************************************************/

class C2cMapAssociationsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    TOPO_MAP_ID
  };
  static const int NUMBER_OF_FIELDS = 2;

public:
  static C2cMapAssociationsSchema & instance()
  {
    static C2cMapAssociationsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cMapAssociationsSchema(const C2cMapAssociationsSchema &) = delete;
  C2cMapAssociationsSchema(C2cMapAssociationsSchema &&) = delete;
  C2cMapAssociationsSchema & operator=(const C2cMapAssociationsSchema &) = delete;
  C2cMapAssociationsSchema & operator=(C2cMapAssociationsSchema &&) = delete;

protected:
  C2cMapAssociationsSchema();
  ~C2cMapAssociationsSchema();
};

/**************************************************************************************************/

class C2cMapAssociations : public QObject, public QoRow<C2cMapAssociationsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(int topo_map_id READ topo_map_id WRITE set_topo_map_id NOTIFY topo_map_idChanged)

public:
  typedef C2cMapAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cMapAssociationsPtr;

public:
  C2cMapAssociations();
  C2cMapAssociations(const C2cMapAssociations & other);
  C2cMapAssociations(const QJsonObject & json_object); // JSON deserializer
  C2cMapAssociations(const QVariantHash & variant_hash);
  C2cMapAssociations(const QVariantList & variants);
  C2cMapAssociations(const QSqlRecord & record); // SQL deserializer
  C2cMapAssociations(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cMapAssociations();

  C2cMapAssociations & operator=(const C2cMapAssociations & other);

  bool operator==(const C2cMapAssociations & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  int topo_map_id() const { return m_topo_map_id; }
  void set_topo_map_id(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_topo_map_id_modified() const { return bit_status(Schema::Fields::TOPO_MAP_ID); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void topo_map_idChanged();

private:
  int m_document_id;
  int m_topo_map_id;

};

QDataStream & operator<<(QDataStream & out, const C2cMapAssociations & obj);
QDataStream & operator>>(QDataStream & in, C2cMapAssociations & obj);
// qRegisterMetaTypeStreamOperators<C2cMapAssociations>("C2cMapAssociations");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cMapAssociations & obj);
#endif

/**************************************************************************************************/

class C2cMapAssociationsPtr
{
public:
  typedef C2cMapAssociations Class;

public:
  C2cMapAssociationsPtr() : m_ptr() {}
  C2cMapAssociationsPtr(const C2cMapAssociationsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cMapAssociationsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cMapAssociationsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cMapAssociationsPtr";
    // m_ptr.clear();
  }

  C2cMapAssociationsPtr & operator=(const C2cMapAssociationsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cMapAssociationsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cMapAssociationsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cMapAssociationsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cMapAssociationsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cMapAssociationsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cMapAssociationsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cMapAssociationsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cMapAssociationsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cMapAssociationsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cMapAssociationsPtr & obj);
#endif

/**************************************************************************************************/

class C2cMapAssociationsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cMapAssociations * t_Key;
  typedef C2cMapAssociationsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cMapAssociationsCache();
  ~C2cMapAssociationsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cMapAssociationsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cMapAssociationsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cMapAssociationsModel();
  C2cMapAssociationsModel(const ItemList & items);
  ~C2cMapAssociationsModel();

  // Fixme: use C2cMapAssociationsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    TOPO_MAP_ID
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cMaps;
class C2cMapsPtr;

/**************************************************************************************************/

class C2cMapsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    CODE,
    EDITOR,
    SCALE
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static C2cMapsSchema & instance()
  {
    static C2cMapsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cMapsSchema(const C2cMapsSchema &) = delete;
  C2cMapsSchema(C2cMapsSchema &&) = delete;
  C2cMapsSchema & operator=(const C2cMapsSchema &) = delete;
  C2cMapsSchema & operator=(C2cMapsSchema &&) = delete;

protected:
  C2cMapsSchema();
  ~C2cMapsSchema();
};

/**************************************************************************************************/

class C2cMaps : public QObject, public QoRow<C2cMapsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString code READ code WRITE set_code NOTIFY codeChanged)
  Q_PROPERTY(QString editor READ editor WRITE set_editor NOTIFY editorChanged)
  Q_PROPERTY(QString scale READ scale WRITE set_scale NOTIFY scaleChanged)

public:
  typedef C2cMapsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cMapsPtr;

public:
  C2cMaps();
  C2cMaps(const C2cMaps & other);
  C2cMaps(const QJsonObject & json_object); // JSON deserializer
  C2cMaps(const QVariantHash & variant_hash);
  C2cMaps(const QVariantList & variants);
  C2cMaps(const QSqlRecord & record); // SQL deserializer
  C2cMaps(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cMaps();

  C2cMaps & operator=(const C2cMaps & other);

  bool operator==(const C2cMaps & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & code() const { return m_code; }
  void set_code(const QString & value);

  const QString & editor() const { return m_editor; }
  void set_editor(const QString & value);

  const QString & scale() const { return m_scale; }
  void set_scale(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_code_modified() const { return bit_status(Schema::Fields::CODE); }
  bool is_editor_modified() const { return bit_status(Schema::Fields::EDITOR); }
  bool is_scale_modified() const { return bit_status(Schema::Fields::SCALE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void codeChanged();
  void editorChanged();
  void scaleChanged();

private:
  int m_document_id;
  QString m_code;
  QString m_editor;
  QString m_scale;

};

QDataStream & operator<<(QDataStream & out, const C2cMaps & obj);
QDataStream & operator>>(QDataStream & in, C2cMaps & obj);
// qRegisterMetaTypeStreamOperators<C2cMaps>("C2cMaps");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cMaps & obj);
#endif

/**************************************************************************************************/

class C2cMapsPtr
{
public:
  typedef C2cMaps Class;

public:
  C2cMapsPtr() : m_ptr() {}
  C2cMapsPtr(const C2cMapsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cMapsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cMapsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cMapsPtr";
    // m_ptr.clear();
  }

  C2cMapsPtr & operator=(const C2cMapsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cMapsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cMapsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cMapsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cMapsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cMapsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cMapsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cMapsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cMapsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cMapsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cMapsPtr & obj);
#endif

/**************************************************************************************************/

class C2cMapsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cMaps * t_Key;
  typedef C2cMapsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cMapsCache();
  ~C2cMapsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cMapsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cMapsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cMapsModel();
  C2cMapsModel(const ItemList & items);
  ~C2cMapsModel();

  // Fixme: use C2cMapsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    CODE,
    EDITOR,
    SCALE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cOutings;
class C2cOutingsPtr;

/**************************************************************************************************/

class C2cOutingsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACCESS_CONDITION,
    ACTIVITIES,
    AVALANCHE_SIGNS,
    CONDITION_RATING,
    DATE_END,
    DATE_START,
    DISABLE_COMMENTS,
    ELEVATION_ACCESS,
    ELEVATION_DOWN_SNOW,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ELEVATION_UP_SNOW,
    FREQUENTATION,
    GLACIER_RATING,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HUT_STATUS,
    LENGTH_TOTAL,
    LIFT_STATUS,
    PARTIAL_TRIP,
    PARTICIPANT_COUNT,
    PUBLIC_TRANSPORT,
    SNOW_QUALITY,
    SNOW_QUANTITY
  };
  static const int NUMBER_OF_FIELDS = 25;

public:
  static C2cOutingsSchema & instance()
  {
    static C2cOutingsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cOutingsSchema(const C2cOutingsSchema &) = delete;
  C2cOutingsSchema(C2cOutingsSchema &&) = delete;
  C2cOutingsSchema & operator=(const C2cOutingsSchema &) = delete;
  C2cOutingsSchema & operator=(C2cOutingsSchema &&) = delete;

protected:
  C2cOutingsSchema();
  ~C2cOutingsSchema();
};

/**************************************************************************************************/

class C2cOutings : public QObject, public QoRow<C2cOutingsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString access_condition READ access_condition WRITE set_access_condition NOTIFY access_conditionChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QStringList avalanche_signs READ avalanche_signs WRITE set_avalanche_signs NOTIFY avalanche_signsChanged)
  Q_PROPERTY(QString condition_rating READ condition_rating WRITE set_condition_rating NOTIFY condition_ratingChanged)
  Q_PROPERTY(QDate date_end READ date_end WRITE set_date_end NOTIFY date_endChanged)
  Q_PROPERTY(QDate date_start READ date_start WRITE set_date_start NOTIFY date_startChanged)
  Q_PROPERTY(bool disable_comments READ disable_comments WRITE set_disable_comments NOTIFY disable_commentsChanged)
  Q_PROPERTY(int elevation_access READ elevation_access WRITE set_elevation_access NOTIFY elevation_accessChanged)
  Q_PROPERTY(int elevation_down_snow READ elevation_down_snow WRITE set_elevation_down_snow NOTIFY elevation_down_snowChanged)
  Q_PROPERTY(int elevation_max READ elevation_max WRITE set_elevation_max NOTIFY elevation_maxChanged)
  Q_PROPERTY(int elevation_min READ elevation_min WRITE set_elevation_min NOTIFY elevation_minChanged)
  Q_PROPERTY(int elevation_up_snow READ elevation_up_snow WRITE set_elevation_up_snow NOTIFY elevation_up_snowChanged)
  Q_PROPERTY(QString frequentation READ frequentation WRITE set_frequentation NOTIFY frequentationChanged)
  Q_PROPERTY(QString glacier_rating READ glacier_rating WRITE set_glacier_rating NOTIFY glacier_ratingChanged)
  Q_PROPERTY(int height_diff_down READ height_diff_down WRITE set_height_diff_down NOTIFY height_diff_downChanged)
  Q_PROPERTY(int height_diff_up READ height_diff_up WRITE set_height_diff_up NOTIFY height_diff_upChanged)
  Q_PROPERTY(QString hut_status READ hut_status WRITE set_hut_status NOTIFY hut_statusChanged)
  Q_PROPERTY(int length_total READ length_total WRITE set_length_total NOTIFY length_totalChanged)
  Q_PROPERTY(QString lift_status READ lift_status WRITE set_lift_status NOTIFY lift_statusChanged)
  Q_PROPERTY(bool partial_trip READ partial_trip WRITE set_partial_trip NOTIFY partial_tripChanged)
  Q_PROPERTY(int participant_count READ participant_count WRITE set_participant_count NOTIFY participant_countChanged)
  Q_PROPERTY(bool public_transport READ public_transport WRITE set_public_transport NOTIFY public_transportChanged)
  Q_PROPERTY(QString snow_quality READ snow_quality WRITE set_snow_quality NOTIFY snow_qualityChanged)
  Q_PROPERTY(QString snow_quantity READ snow_quantity WRITE set_snow_quantity NOTIFY snow_quantityChanged)

public:
  typedef C2cOutingsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cOutingsPtr;

public:
  C2cOutings();
  C2cOutings(const C2cOutings & other);
  C2cOutings(const QJsonObject & json_object); // JSON deserializer
  C2cOutings(const QVariantHash & variant_hash);
  C2cOutings(const QVariantList & variants);
  C2cOutings(const QSqlRecord & record); // SQL deserializer
  C2cOutings(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cOutings();

  C2cOutings & operator=(const C2cOutings & other);

  bool operator==(const C2cOutings & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & access_condition() const { return m_access_condition; }
  void set_access_condition(const QString & value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QStringList & avalanche_signs() const { return m_avalanche_signs; }
  void set_avalanche_signs(const QStringList & value);

  const QString & condition_rating() const { return m_condition_rating; }
  void set_condition_rating(const QString & value);

  const QDate & date_end() const { return m_date_end; }
  void set_date_end(const QDate & value);

  const QDate & date_start() const { return m_date_start; }
  void set_date_start(const QDate & value);

  bool disable_comments() const { return m_disable_comments; }
  void set_disable_comments(bool value);

  int elevation_access() const { return m_elevation_access; }
  void set_elevation_access(int value);

  int elevation_down_snow() const { return m_elevation_down_snow; }
  void set_elevation_down_snow(int value);

  int elevation_max() const { return m_elevation_max; }
  void set_elevation_max(int value);

  int elevation_min() const { return m_elevation_min; }
  void set_elevation_min(int value);

  int elevation_up_snow() const { return m_elevation_up_snow; }
  void set_elevation_up_snow(int value);

  const QString & frequentation() const { return m_frequentation; }
  void set_frequentation(const QString & value);

  const QString & glacier_rating() const { return m_glacier_rating; }
  void set_glacier_rating(const QString & value);

  int height_diff_down() const { return m_height_diff_down; }
  void set_height_diff_down(int value);

  int height_diff_up() const { return m_height_diff_up; }
  void set_height_diff_up(int value);

  const QString & hut_status() const { return m_hut_status; }
  void set_hut_status(const QString & value);

  int length_total() const { return m_length_total; }
  void set_length_total(int value);

  const QString & lift_status() const { return m_lift_status; }
  void set_lift_status(const QString & value);

  bool partial_trip() const { return m_partial_trip; }
  void set_partial_trip(bool value);

  int participant_count() const { return m_participant_count; }
  void set_participant_count(int value);

  bool public_transport() const { return m_public_transport; }
  void set_public_transport(bool value);

  const QString & snow_quality() const { return m_snow_quality; }
  void set_snow_quality(const QString & value);

  const QString & snow_quantity() const { return m_snow_quantity; }
  void set_snow_quantity(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_access_condition_modified() const { return bit_status(Schema::Fields::ACCESS_CONDITION); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_avalanche_signs_modified() const { return bit_status(Schema::Fields::AVALANCHE_SIGNS); }
  bool is_condition_rating_modified() const { return bit_status(Schema::Fields::CONDITION_RATING); }
  bool is_date_end_modified() const { return bit_status(Schema::Fields::DATE_END); }
  bool is_date_start_modified() const { return bit_status(Schema::Fields::DATE_START); }
  bool is_disable_comments_modified() const { return bit_status(Schema::Fields::DISABLE_COMMENTS); }
  bool is_elevation_access_modified() const { return bit_status(Schema::Fields::ELEVATION_ACCESS); }
  bool is_elevation_down_snow_modified() const { return bit_status(Schema::Fields::ELEVATION_DOWN_SNOW); }
  bool is_elevation_max_modified() const { return bit_status(Schema::Fields::ELEVATION_MAX); }
  bool is_elevation_min_modified() const { return bit_status(Schema::Fields::ELEVATION_MIN); }
  bool is_elevation_up_snow_modified() const { return bit_status(Schema::Fields::ELEVATION_UP_SNOW); }
  bool is_frequentation_modified() const { return bit_status(Schema::Fields::FREQUENTATION); }
  bool is_glacier_rating_modified() const { return bit_status(Schema::Fields::GLACIER_RATING); }
  bool is_height_diff_down_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_DOWN); }
  bool is_height_diff_up_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_UP); }
  bool is_hut_status_modified() const { return bit_status(Schema::Fields::HUT_STATUS); }
  bool is_length_total_modified() const { return bit_status(Schema::Fields::LENGTH_TOTAL); }
  bool is_lift_status_modified() const { return bit_status(Schema::Fields::LIFT_STATUS); }
  bool is_partial_trip_modified() const { return bit_status(Schema::Fields::PARTIAL_TRIP); }
  bool is_participant_count_modified() const { return bit_status(Schema::Fields::PARTICIPANT_COUNT); }
  bool is_public_transport_modified() const { return bit_status(Schema::Fields::PUBLIC_TRANSPORT); }
  bool is_snow_quality_modified() const { return bit_status(Schema::Fields::SNOW_QUALITY); }
  bool is_snow_quantity_modified() const { return bit_status(Schema::Fields::SNOW_QUANTITY); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void access_conditionChanged();
  void activitiesChanged();
  void avalanche_signsChanged();
  void condition_ratingChanged();
  void date_endChanged();
  void date_startChanged();
  void disable_commentsChanged();
  void elevation_accessChanged();
  void elevation_down_snowChanged();
  void elevation_maxChanged();
  void elevation_minChanged();
  void elevation_up_snowChanged();
  void frequentationChanged();
  void glacier_ratingChanged();
  void height_diff_downChanged();
  void height_diff_upChanged();
  void hut_statusChanged();
  void length_totalChanged();
  void lift_statusChanged();
  void partial_tripChanged();
  void participant_countChanged();
  void public_transportChanged();
  void snow_qualityChanged();
  void snow_quantityChanged();

private:
  int m_document_id;
  QString m_access_condition;
  QStringList m_activities;
  QStringList m_avalanche_signs;
  QString m_condition_rating;
  QDate m_date_end;
  QDate m_date_start;
  bool m_disable_comments;
  int m_elevation_access;
  int m_elevation_down_snow;
  int m_elevation_max;
  int m_elevation_min;
  int m_elevation_up_snow;
  QString m_frequentation;
  QString m_glacier_rating;
  int m_height_diff_down;
  int m_height_diff_up;
  QString m_hut_status;
  int m_length_total;
  QString m_lift_status;
  bool m_partial_trip;
  int m_participant_count;
  bool m_public_transport;
  QString m_snow_quality;
  QString m_snow_quantity;

};

QDataStream & operator<<(QDataStream & out, const C2cOutings & obj);
QDataStream & operator>>(QDataStream & in, C2cOutings & obj);
// qRegisterMetaTypeStreamOperators<C2cOutings>("C2cOutings");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cOutings & obj);
#endif

/**************************************************************************************************/

class C2cOutingsPtr
{
public:
  typedef C2cOutings Class;

public:
  C2cOutingsPtr() : m_ptr() {}
  C2cOutingsPtr(const C2cOutingsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cOutingsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cOutingsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cOutingsPtr";
    // m_ptr.clear();
  }

  C2cOutingsPtr & operator=(const C2cOutingsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cOutingsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cOutingsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cOutingsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cOutingsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cOutingsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cOutingsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cOutingsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cOutingsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cOutingsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cOutingsPtr & obj);
#endif

/**************************************************************************************************/

class C2cOutingsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cOutings * t_Key;
  typedef C2cOutingsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cOutingsCache();
  ~C2cOutingsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cOutingsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cOutingsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cOutingsModel();
  C2cOutingsModel(const ItemList & items);
  ~C2cOutingsModel();

  // Fixme: use C2cOutingsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACCESS_CONDITION,
    ACTIVITIES,
    AVALANCHE_SIGNS,
    CONDITION_RATING,
    DATE_END,
    DATE_START,
    DISABLE_COMMENTS,
    ELEVATION_ACCESS,
    ELEVATION_DOWN_SNOW,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ELEVATION_UP_SNOW,
    FREQUENTATION,
    GLACIER_RATING,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HUT_STATUS,
    LENGTH_TOTAL,
    LIFT_STATUS,
    PARTIAL_TRIP,
    PARTICIPANT_COUNT,
    PUBLIC_TRANSPORT,
    SNOW_QUALITY,
    SNOW_QUANTITY
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cOutingsLocales;
class C2cOutingsLocalesPtr;

/**************************************************************************************************/

class C2cOutingsLocalesSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    ACCESS_COMMENT,
    AVALANCHES,
    CONDITIONS,
    CONDITIONS_LEVELS,
    HUT_COMMENT,
    PARTICIPANTS,
    ROUTE_DESCRIPTION,
    TIMING,
    WEATHER
  };
  static const int NUMBER_OF_FIELDS = 10;

public:
  static C2cOutingsLocalesSchema & instance()
  {
    static C2cOutingsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cOutingsLocalesSchema(const C2cOutingsLocalesSchema &) = delete;
  C2cOutingsLocalesSchema(C2cOutingsLocalesSchema &&) = delete;
  C2cOutingsLocalesSchema & operator=(const C2cOutingsLocalesSchema &) = delete;
  C2cOutingsLocalesSchema & operator=(C2cOutingsLocalesSchema &&) = delete;

protected:
  C2cOutingsLocalesSchema();
  ~C2cOutingsLocalesSchema();
};

/**************************************************************************************************/

class C2cOutingsLocales : public QObject, public QoRow<C2cOutingsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString access_comment READ access_comment WRITE set_access_comment NOTIFY access_commentChanged)
  Q_PROPERTY(QString avalanches READ avalanches WRITE set_avalanches NOTIFY avalanchesChanged)
  Q_PROPERTY(QString conditions READ conditions WRITE set_conditions NOTIFY conditionsChanged)
  Q_PROPERTY(QString conditions_levels READ conditions_levels WRITE set_conditions_levels NOTIFY conditions_levelsChanged)
  Q_PROPERTY(QString hut_comment READ hut_comment WRITE set_hut_comment NOTIFY hut_commentChanged)
  Q_PROPERTY(QString participants READ participants WRITE set_participants NOTIFY participantsChanged)
  Q_PROPERTY(QString route_description READ route_description WRITE set_route_description NOTIFY route_descriptionChanged)
  Q_PROPERTY(QString timing READ timing WRITE set_timing NOTIFY timingChanged)
  Q_PROPERTY(QString weather READ weather WRITE set_weather NOTIFY weatherChanged)

public:
  typedef C2cOutingsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cOutingsLocalesPtr;

public:
  C2cOutingsLocales();
  C2cOutingsLocales(const C2cOutingsLocales & other);
  C2cOutingsLocales(const QJsonObject & json_object); // JSON deserializer
  C2cOutingsLocales(const QVariantHash & variant_hash);
  C2cOutingsLocales(const QVariantList & variants);
  C2cOutingsLocales(const QSqlRecord & record); // SQL deserializer
  C2cOutingsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cOutingsLocales();

  C2cOutingsLocales & operator=(const C2cOutingsLocales & other);

  bool operator==(const C2cOutingsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & access_comment() const { return m_access_comment; }
  void set_access_comment(const QString & value);

  const QString & avalanches() const { return m_avalanches; }
  void set_avalanches(const QString & value);

  const QString & conditions() const { return m_conditions; }
  void set_conditions(const QString & value);

  const QString & conditions_levels() const { return m_conditions_levels; }
  void set_conditions_levels(const QString & value);

  const QString & hut_comment() const { return m_hut_comment; }
  void set_hut_comment(const QString & value);

  const QString & participants() const { return m_participants; }
  void set_participants(const QString & value);

  const QString & route_description() const { return m_route_description; }
  void set_route_description(const QString & value);

  const QString & timing() const { return m_timing; }
  void set_timing(const QString & value);

  const QString & weather() const { return m_weather; }
  void set_weather(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_access_comment_modified() const { return bit_status(Schema::Fields::ACCESS_COMMENT); }
  bool is_avalanches_modified() const { return bit_status(Schema::Fields::AVALANCHES); }
  bool is_conditions_modified() const { return bit_status(Schema::Fields::CONDITIONS); }
  bool is_conditions_levels_modified() const { return bit_status(Schema::Fields::CONDITIONS_LEVELS); }
  bool is_hut_comment_modified() const { return bit_status(Schema::Fields::HUT_COMMENT); }
  bool is_participants_modified() const { return bit_status(Schema::Fields::PARTICIPANTS); }
  bool is_route_description_modified() const { return bit_status(Schema::Fields::ROUTE_DESCRIPTION); }
  bool is_timing_modified() const { return bit_status(Schema::Fields::TIMING); }
  bool is_weather_modified() const { return bit_status(Schema::Fields::WEATHER); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void access_commentChanged();
  void avalanchesChanged();
  void conditionsChanged();
  void conditions_levelsChanged();
  void hut_commentChanged();
  void participantsChanged();
  void route_descriptionChanged();
  void timingChanged();
  void weatherChanged();

private:
  int m_id;
  QString m_access_comment;
  QString m_avalanches;
  QString m_conditions;
  QString m_conditions_levels;
  QString m_hut_comment;
  QString m_participants;
  QString m_route_description;
  QString m_timing;
  QString m_weather;

};

QDataStream & operator<<(QDataStream & out, const C2cOutingsLocales & obj);
QDataStream & operator>>(QDataStream & in, C2cOutingsLocales & obj);
// qRegisterMetaTypeStreamOperators<C2cOutingsLocales>("C2cOutingsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cOutingsLocales & obj);
#endif

/**************************************************************************************************/

class C2cOutingsLocalesPtr
{
public:
  typedef C2cOutingsLocales Class;

public:
  C2cOutingsLocalesPtr() : m_ptr() {}
  C2cOutingsLocalesPtr(const C2cOutingsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cOutingsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cOutingsLocalesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cOutingsLocalesPtr";
    // m_ptr.clear();
  }

  C2cOutingsLocalesPtr & operator=(const C2cOutingsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cOutingsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cOutingsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cOutingsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cOutingsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cOutingsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cOutingsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cOutingsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cOutingsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cOutingsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cOutingsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class C2cOutingsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cOutingsLocales * t_Key;
  typedef C2cOutingsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cOutingsLocalesCache();
  ~C2cOutingsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cOutingsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cOutingsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cOutingsLocalesModel();
  C2cOutingsLocalesModel(const ItemList & items);
  ~C2cOutingsLocalesModel();

  // Fixme: use C2cOutingsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    ACCESS_COMMENT,
    AVALANCHES,
    CONDITIONS,
    CONDITIONS_LEVELS,
    HUT_COMMENT,
    PARTICIPANTS,
    ROUTE_DESCRIPTION,
    TIMING,
    WEATHER
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cRoutes;
class C2cRoutesPtr;

/**************************************************************************************************/

class C2cRoutesSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    AID_RATING,
    CLIMBING_OUTDOOR_TYPE,
    CONFIGURATION,
    DIFFICULTIES_HEIGHT,
    DURATIONS,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ENGAGEMENT_RATING,
    EQUIPMENT_RATING,
    EXPOSITION_ROCK_RATING,
    GLACIER_GEAR,
    GLOBAL_RATING,
    HEIGHT_DIFF_ACCESS,
    HEIGHT_DIFF_DIFFICULTIES,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HIKING_MTB_EXPOSITION,
    HIKING_RATING,
    ICE_RATING,
    LABANDE_GLOBAL_RATING,
    LABANDE_SKI_RATING,
    LIFT_ACCESS,
    MAIN_WAYPOINT_ID,
    MIXED_RATING,
    MTB_DOWN_RATING,
    MTB_HEIGHT_DIFF_PORTAGES,
    MTB_LENGTH_ASPHALT,
    MTB_LENGTH_TRAIL,
    MTB_UP_RATING,
    ORIENTATIONS,
    RISK_RATING,
    ROCK_FREE_RATING,
    ROCK_REQUIRED_RATING,
    ROCK_TYPES,
    ROUTE_LENGTH,
    ROUTE_TYPES,
    SKI_EXPOSITION,
    SKI_RATING,
    SLACKLINE_HEIGHT,
    SLACKLINE_TYPE,
    SNOWSHOE_RATING,
    VIA_FERRATA_RATING
  };
  static const int NUMBER_OF_FIELDS = 44;

public:
  static C2cRoutesSchema & instance()
  {
    static C2cRoutesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cRoutesSchema(const C2cRoutesSchema &) = delete;
  C2cRoutesSchema(C2cRoutesSchema &&) = delete;
  C2cRoutesSchema & operator=(const C2cRoutesSchema &) = delete;
  C2cRoutesSchema & operator=(C2cRoutesSchema &&) = delete;

protected:
  C2cRoutesSchema();
  ~C2cRoutesSchema();
};

/**************************************************************************************************/

class C2cRoutes : public QObject, public QoRow<C2cRoutesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString aid_rating READ aid_rating WRITE set_aid_rating NOTIFY aid_ratingChanged)
  Q_PROPERTY(QString climbing_outdoor_type READ climbing_outdoor_type WRITE set_climbing_outdoor_type NOTIFY climbing_outdoor_typeChanged)
  Q_PROPERTY(QStringList configuration READ configuration WRITE set_configuration NOTIFY configurationChanged)
  Q_PROPERTY(int difficulties_height READ difficulties_height WRITE set_difficulties_height NOTIFY difficulties_heightChanged)
  Q_PROPERTY(QStringList durations READ durations WRITE set_durations NOTIFY durationsChanged)
  Q_PROPERTY(int elevation_max READ elevation_max WRITE set_elevation_max NOTIFY elevation_maxChanged)
  Q_PROPERTY(int elevation_min READ elevation_min WRITE set_elevation_min NOTIFY elevation_minChanged)
  Q_PROPERTY(QString engagement_rating READ engagement_rating WRITE set_engagement_rating NOTIFY engagement_ratingChanged)
  Q_PROPERTY(QString equipment_rating READ equipment_rating WRITE set_equipment_rating NOTIFY equipment_ratingChanged)
  Q_PROPERTY(QString exposition_rock_rating READ exposition_rock_rating WRITE set_exposition_rock_rating NOTIFY exposition_rock_ratingChanged)
  Q_PROPERTY(QString glacier_gear READ glacier_gear WRITE set_glacier_gear NOTIFY glacier_gearChanged)
  Q_PROPERTY(QString global_rating READ global_rating WRITE set_global_rating NOTIFY global_ratingChanged)
  Q_PROPERTY(int height_diff_access READ height_diff_access WRITE set_height_diff_access NOTIFY height_diff_accessChanged)
  Q_PROPERTY(int height_diff_difficulties READ height_diff_difficulties WRITE set_height_diff_difficulties NOTIFY height_diff_difficultiesChanged)
  Q_PROPERTY(int height_diff_down READ height_diff_down WRITE set_height_diff_down NOTIFY height_diff_downChanged)
  Q_PROPERTY(int height_diff_up READ height_diff_up WRITE set_height_diff_up NOTIFY height_diff_upChanged)
  Q_PROPERTY(QString hiking_mtb_exposition READ hiking_mtb_exposition WRITE set_hiking_mtb_exposition NOTIFY hiking_mtb_expositionChanged)
  Q_PROPERTY(QString hiking_rating READ hiking_rating WRITE set_hiking_rating NOTIFY hiking_ratingChanged)
  Q_PROPERTY(QString ice_rating READ ice_rating WRITE set_ice_rating NOTIFY ice_ratingChanged)
  Q_PROPERTY(QString labande_global_rating READ labande_global_rating WRITE set_labande_global_rating NOTIFY labande_global_ratingChanged)
  Q_PROPERTY(QString labande_ski_rating READ labande_ski_rating WRITE set_labande_ski_rating NOTIFY labande_ski_ratingChanged)
  Q_PROPERTY(bool lift_access READ lift_access WRITE set_lift_access NOTIFY lift_accessChanged)
  Q_PROPERTY(int main_waypoint_id READ main_waypoint_id WRITE set_main_waypoint_id NOTIFY main_waypoint_idChanged)
  Q_PROPERTY(QString mixed_rating READ mixed_rating WRITE set_mixed_rating NOTIFY mixed_ratingChanged)
  Q_PROPERTY(QString mtb_down_rating READ mtb_down_rating WRITE set_mtb_down_rating NOTIFY mtb_down_ratingChanged)
  Q_PROPERTY(int mtb_height_diff_portages READ mtb_height_diff_portages WRITE set_mtb_height_diff_portages NOTIFY mtb_height_diff_portagesChanged)
  Q_PROPERTY(int mtb_length_asphalt READ mtb_length_asphalt WRITE set_mtb_length_asphalt NOTIFY mtb_length_asphaltChanged)
  Q_PROPERTY(int mtb_length_trail READ mtb_length_trail WRITE set_mtb_length_trail NOTIFY mtb_length_trailChanged)
  Q_PROPERTY(QString mtb_up_rating READ mtb_up_rating WRITE set_mtb_up_rating NOTIFY mtb_up_ratingChanged)
  Q_PROPERTY(QStringList orientations READ orientations WRITE set_orientations NOTIFY orientationsChanged)
  Q_PROPERTY(QString risk_rating READ risk_rating WRITE set_risk_rating NOTIFY risk_ratingChanged)
  Q_PROPERTY(QString rock_free_rating READ rock_free_rating WRITE set_rock_free_rating NOTIFY rock_free_ratingChanged)
  Q_PROPERTY(QString rock_required_rating READ rock_required_rating WRITE set_rock_required_rating NOTIFY rock_required_ratingChanged)
  Q_PROPERTY(QStringList rock_types READ rock_types WRITE set_rock_types NOTIFY rock_typesChanged)
  Q_PROPERTY(int route_length READ route_length WRITE set_route_length NOTIFY route_lengthChanged)
  Q_PROPERTY(QStringList route_types READ route_types WRITE set_route_types NOTIFY route_typesChanged)
  Q_PROPERTY(QString ski_exposition READ ski_exposition WRITE set_ski_exposition NOTIFY ski_expositionChanged)
  Q_PROPERTY(QString ski_rating READ ski_rating WRITE set_ski_rating NOTIFY ski_ratingChanged)
  Q_PROPERTY(int slackline_height READ slackline_height WRITE set_slackline_height NOTIFY slackline_heightChanged)
  Q_PROPERTY(QString slackline_type READ slackline_type WRITE set_slackline_type NOTIFY slackline_typeChanged)
  Q_PROPERTY(QString snowshoe_rating READ snowshoe_rating WRITE set_snowshoe_rating NOTIFY snowshoe_ratingChanged)
  Q_PROPERTY(QString via_ferrata_rating READ via_ferrata_rating WRITE set_via_ferrata_rating NOTIFY via_ferrata_ratingChanged)

public:
  typedef C2cRoutesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cRoutesPtr;

public:
  C2cRoutes();
  C2cRoutes(const C2cRoutes & other);
  C2cRoutes(const QJsonObject & json_object); // JSON deserializer
  C2cRoutes(const QVariantHash & variant_hash);
  C2cRoutes(const QVariantList & variants);
  C2cRoutes(const QSqlRecord & record); // SQL deserializer
  C2cRoutes(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cRoutes();

  C2cRoutes & operator=(const C2cRoutes & other);

  bool operator==(const C2cRoutes & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & aid_rating() const { return m_aid_rating; }
  void set_aid_rating(const QString & value);

  const QString & climbing_outdoor_type() const { return m_climbing_outdoor_type; }
  void set_climbing_outdoor_type(const QString & value);

  const QStringList & configuration() const { return m_configuration; }
  void set_configuration(const QStringList & value);

  int difficulties_height() const { return m_difficulties_height; }
  void set_difficulties_height(int value);

  const QStringList & durations() const { return m_durations; }
  void set_durations(const QStringList & value);

  int elevation_max() const { return m_elevation_max; }
  void set_elevation_max(int value);

  int elevation_min() const { return m_elevation_min; }
  void set_elevation_min(int value);

  const QString & engagement_rating() const { return m_engagement_rating; }
  void set_engagement_rating(const QString & value);

  const QString & equipment_rating() const { return m_equipment_rating; }
  void set_equipment_rating(const QString & value);

  const QString & exposition_rock_rating() const { return m_exposition_rock_rating; }
  void set_exposition_rock_rating(const QString & value);

  const QString & glacier_gear() const { return m_glacier_gear; }
  void set_glacier_gear(const QString & value);

  const QString & global_rating() const { return m_global_rating; }
  void set_global_rating(const QString & value);

  int height_diff_access() const { return m_height_diff_access; }
  void set_height_diff_access(int value);

  int height_diff_difficulties() const { return m_height_diff_difficulties; }
  void set_height_diff_difficulties(int value);

  int height_diff_down() const { return m_height_diff_down; }
  void set_height_diff_down(int value);

  int height_diff_up() const { return m_height_diff_up; }
  void set_height_diff_up(int value);

  const QString & hiking_mtb_exposition() const { return m_hiking_mtb_exposition; }
  void set_hiking_mtb_exposition(const QString & value);

  const QString & hiking_rating() const { return m_hiking_rating; }
  void set_hiking_rating(const QString & value);

  const QString & ice_rating() const { return m_ice_rating; }
  void set_ice_rating(const QString & value);

  const QString & labande_global_rating() const { return m_labande_global_rating; }
  void set_labande_global_rating(const QString & value);

  const QString & labande_ski_rating() const { return m_labande_ski_rating; }
  void set_labande_ski_rating(const QString & value);

  bool lift_access() const { return m_lift_access; }
  void set_lift_access(bool value);

  int main_waypoint_id() const { return m_main_waypoint_id; }
  void set_main_waypoint_id(int value);

  const QString & mixed_rating() const { return m_mixed_rating; }
  void set_mixed_rating(const QString & value);

  const QString & mtb_down_rating() const { return m_mtb_down_rating; }
  void set_mtb_down_rating(const QString & value);

  int mtb_height_diff_portages() const { return m_mtb_height_diff_portages; }
  void set_mtb_height_diff_portages(int value);

  int mtb_length_asphalt() const { return m_mtb_length_asphalt; }
  void set_mtb_length_asphalt(int value);

  int mtb_length_trail() const { return m_mtb_length_trail; }
  void set_mtb_length_trail(int value);

  const QString & mtb_up_rating() const { return m_mtb_up_rating; }
  void set_mtb_up_rating(const QString & value);

  const QStringList & orientations() const { return m_orientations; }
  void set_orientations(const QStringList & value);

  const QString & risk_rating() const { return m_risk_rating; }
  void set_risk_rating(const QString & value);

  const QString & rock_free_rating() const { return m_rock_free_rating; }
  void set_rock_free_rating(const QString & value);

  const QString & rock_required_rating() const { return m_rock_required_rating; }
  void set_rock_required_rating(const QString & value);

  const QStringList & rock_types() const { return m_rock_types; }
  void set_rock_types(const QStringList & value);

  int route_length() const { return m_route_length; }
  void set_route_length(int value);

  const QStringList & route_types() const { return m_route_types; }
  void set_route_types(const QStringList & value);

  const QString & ski_exposition() const { return m_ski_exposition; }
  void set_ski_exposition(const QString & value);

  const QString & ski_rating() const { return m_ski_rating; }
  void set_ski_rating(const QString & value);

  int slackline_height() const { return m_slackline_height; }
  void set_slackline_height(int value);

  const QString & slackline_type() const { return m_slackline_type; }
  void set_slackline_type(const QString & value);

  const QString & snowshoe_rating() const { return m_snowshoe_rating; }
  void set_snowshoe_rating(const QString & value);

  const QString & via_ferrata_rating() const { return m_via_ferrata_rating; }
  void set_via_ferrata_rating(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_aid_rating_modified() const { return bit_status(Schema::Fields::AID_RATING); }
  bool is_climbing_outdoor_type_modified() const { return bit_status(Schema::Fields::CLIMBING_OUTDOOR_TYPE); }
  bool is_configuration_modified() const { return bit_status(Schema::Fields::CONFIGURATION); }
  bool is_difficulties_height_modified() const { return bit_status(Schema::Fields::DIFFICULTIES_HEIGHT); }
  bool is_durations_modified() const { return bit_status(Schema::Fields::DURATIONS); }
  bool is_elevation_max_modified() const { return bit_status(Schema::Fields::ELEVATION_MAX); }
  bool is_elevation_min_modified() const { return bit_status(Schema::Fields::ELEVATION_MIN); }
  bool is_engagement_rating_modified() const { return bit_status(Schema::Fields::ENGAGEMENT_RATING); }
  bool is_equipment_rating_modified() const { return bit_status(Schema::Fields::EQUIPMENT_RATING); }
  bool is_exposition_rock_rating_modified() const { return bit_status(Schema::Fields::EXPOSITION_ROCK_RATING); }
  bool is_glacier_gear_modified() const { return bit_status(Schema::Fields::GLACIER_GEAR); }
  bool is_global_rating_modified() const { return bit_status(Schema::Fields::GLOBAL_RATING); }
  bool is_height_diff_access_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_ACCESS); }
  bool is_height_diff_difficulties_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_DIFFICULTIES); }
  bool is_height_diff_down_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_DOWN); }
  bool is_height_diff_up_modified() const { return bit_status(Schema::Fields::HEIGHT_DIFF_UP); }
  bool is_hiking_mtb_exposition_modified() const { return bit_status(Schema::Fields::HIKING_MTB_EXPOSITION); }
  bool is_hiking_rating_modified() const { return bit_status(Schema::Fields::HIKING_RATING); }
  bool is_ice_rating_modified() const { return bit_status(Schema::Fields::ICE_RATING); }
  bool is_labande_global_rating_modified() const { return bit_status(Schema::Fields::LABANDE_GLOBAL_RATING); }
  bool is_labande_ski_rating_modified() const { return bit_status(Schema::Fields::LABANDE_SKI_RATING); }
  bool is_lift_access_modified() const { return bit_status(Schema::Fields::LIFT_ACCESS); }
  bool is_main_waypoint_id_modified() const { return bit_status(Schema::Fields::MAIN_WAYPOINT_ID); }
  bool is_mixed_rating_modified() const { return bit_status(Schema::Fields::MIXED_RATING); }
  bool is_mtb_down_rating_modified() const { return bit_status(Schema::Fields::MTB_DOWN_RATING); }
  bool is_mtb_height_diff_portages_modified() const { return bit_status(Schema::Fields::MTB_HEIGHT_DIFF_PORTAGES); }
  bool is_mtb_length_asphalt_modified() const { return bit_status(Schema::Fields::MTB_LENGTH_ASPHALT); }
  bool is_mtb_length_trail_modified() const { return bit_status(Schema::Fields::MTB_LENGTH_TRAIL); }
  bool is_mtb_up_rating_modified() const { return bit_status(Schema::Fields::MTB_UP_RATING); }
  bool is_orientations_modified() const { return bit_status(Schema::Fields::ORIENTATIONS); }
  bool is_risk_rating_modified() const { return bit_status(Schema::Fields::RISK_RATING); }
  bool is_rock_free_rating_modified() const { return bit_status(Schema::Fields::ROCK_FREE_RATING); }
  bool is_rock_required_rating_modified() const { return bit_status(Schema::Fields::ROCK_REQUIRED_RATING); }
  bool is_rock_types_modified() const { return bit_status(Schema::Fields::ROCK_TYPES); }
  bool is_route_length_modified() const { return bit_status(Schema::Fields::ROUTE_LENGTH); }
  bool is_route_types_modified() const { return bit_status(Schema::Fields::ROUTE_TYPES); }
  bool is_ski_exposition_modified() const { return bit_status(Schema::Fields::SKI_EXPOSITION); }
  bool is_ski_rating_modified() const { return bit_status(Schema::Fields::SKI_RATING); }
  bool is_slackline_height_modified() const { return bit_status(Schema::Fields::SLACKLINE_HEIGHT); }
  bool is_slackline_type_modified() const { return bit_status(Schema::Fields::SLACKLINE_TYPE); }
  bool is_snowshoe_rating_modified() const { return bit_status(Schema::Fields::SNOWSHOE_RATING); }
  bool is_via_ferrata_rating_modified() const { return bit_status(Schema::Fields::VIA_FERRATA_RATING); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void aid_ratingChanged();
  void climbing_outdoor_typeChanged();
  void configurationChanged();
  void difficulties_heightChanged();
  void durationsChanged();
  void elevation_maxChanged();
  void elevation_minChanged();
  void engagement_ratingChanged();
  void equipment_ratingChanged();
  void exposition_rock_ratingChanged();
  void glacier_gearChanged();
  void global_ratingChanged();
  void height_diff_accessChanged();
  void height_diff_difficultiesChanged();
  void height_diff_downChanged();
  void height_diff_upChanged();
  void hiking_mtb_expositionChanged();
  void hiking_ratingChanged();
  void ice_ratingChanged();
  void labande_global_ratingChanged();
  void labande_ski_ratingChanged();
  void lift_accessChanged();
  void main_waypoint_idChanged();
  void mixed_ratingChanged();
  void mtb_down_ratingChanged();
  void mtb_height_diff_portagesChanged();
  void mtb_length_asphaltChanged();
  void mtb_length_trailChanged();
  void mtb_up_ratingChanged();
  void orientationsChanged();
  void risk_ratingChanged();
  void rock_free_ratingChanged();
  void rock_required_ratingChanged();
  void rock_typesChanged();
  void route_lengthChanged();
  void route_typesChanged();
  void ski_expositionChanged();
  void ski_ratingChanged();
  void slackline_heightChanged();
  void slackline_typeChanged();
  void snowshoe_ratingChanged();
  void via_ferrata_ratingChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_aid_rating;
  QString m_climbing_outdoor_type;
  QStringList m_configuration;
  int m_difficulties_height;
  QStringList m_durations;
  int m_elevation_max;
  int m_elevation_min;
  QString m_engagement_rating;
  QString m_equipment_rating;
  QString m_exposition_rock_rating;
  QString m_glacier_gear;
  QString m_global_rating;
  int m_height_diff_access;
  int m_height_diff_difficulties;
  int m_height_diff_down;
  int m_height_diff_up;
  QString m_hiking_mtb_exposition;
  QString m_hiking_rating;
  QString m_ice_rating;
  QString m_labande_global_rating;
  QString m_labande_ski_rating;
  bool m_lift_access;
  int m_main_waypoint_id;
  QString m_mixed_rating;
  QString m_mtb_down_rating;
  int m_mtb_height_diff_portages;
  int m_mtb_length_asphalt;
  int m_mtb_length_trail;
  QString m_mtb_up_rating;
  QStringList m_orientations;
  QString m_risk_rating;
  QString m_rock_free_rating;
  QString m_rock_required_rating;
  QStringList m_rock_types;
  int m_route_length;
  QStringList m_route_types;
  QString m_ski_exposition;
  QString m_ski_rating;
  int m_slackline_height;
  QString m_slackline_type;
  QString m_snowshoe_rating;
  QString m_via_ferrata_rating;

};

QDataStream & operator<<(QDataStream & out, const C2cRoutes & obj);
QDataStream & operator>>(QDataStream & in, C2cRoutes & obj);
// qRegisterMetaTypeStreamOperators<C2cRoutes>("C2cRoutes");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cRoutes & obj);
#endif

/**************************************************************************************************/

class C2cRoutesPtr
{
public:
  typedef C2cRoutes Class;

public:
  C2cRoutesPtr() : m_ptr() {}
  C2cRoutesPtr(const C2cRoutesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cRoutesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cRoutesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cRoutesPtr";
    // m_ptr.clear();
  }

  C2cRoutesPtr & operator=(const C2cRoutesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cRoutesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cRoutesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cRoutesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cRoutesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cRoutesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cRoutesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cRoutesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cRoutesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cRoutesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cRoutesPtr & obj);
#endif

/**************************************************************************************************/

class C2cRoutesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cRoutes * t_Key;
  typedef C2cRoutesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cRoutesCache();
  ~C2cRoutesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cRoutesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cRoutesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cRoutesModel();
  C2cRoutesModel(const ItemList & items);
  ~C2cRoutesModel();

  // Fixme: use C2cRoutesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    AID_RATING,
    CLIMBING_OUTDOOR_TYPE,
    CONFIGURATION,
    DIFFICULTIES_HEIGHT,
    DURATIONS,
    ELEVATION_MAX,
    ELEVATION_MIN,
    ENGAGEMENT_RATING,
    EQUIPMENT_RATING,
    EXPOSITION_ROCK_RATING,
    GLACIER_GEAR,
    GLOBAL_RATING,
    HEIGHT_DIFF_ACCESS,
    HEIGHT_DIFF_DIFFICULTIES,
    HEIGHT_DIFF_DOWN,
    HEIGHT_DIFF_UP,
    HIKING_MTB_EXPOSITION,
    HIKING_RATING,
    ICE_RATING,
    LABANDE_GLOBAL_RATING,
    LABANDE_SKI_RATING,
    LIFT_ACCESS,
    MAIN_WAYPOINT_ID,
    MIXED_RATING,
    MTB_DOWN_RATING,
    MTB_HEIGHT_DIFF_PORTAGES,
    MTB_LENGTH_ASPHALT,
    MTB_LENGTH_TRAIL,
    MTB_UP_RATING,
    ORIENTATIONS,
    RISK_RATING,
    ROCK_FREE_RATING,
    ROCK_REQUIRED_RATING,
    ROCK_TYPES,
    ROUTE_LENGTH,
    ROUTE_TYPES,
    SKI_EXPOSITION,
    SKI_RATING,
    SLACKLINE_HEIGHT,
    SLACKLINE_TYPE,
    SNOWSHOE_RATING,
    VIA_FERRATA_RATING
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cRoutesLocales;
class C2cRoutesLocalesPtr;

/**************************************************************************************************/

class C2cRoutesLocalesSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    EXTERNAL_RESOURCES,
    GEAR,
    REMARKS,
    ROUTE_HISTORY,
    SLACKLINE_ANCHOR1,
    SLACKLINE_ANCHOR2,
    SLOPE,
    TITLE_PREFIX
  };
  static const int NUMBER_OF_FIELDS = 9;

public:
  static C2cRoutesLocalesSchema & instance()
  {
    static C2cRoutesLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cRoutesLocalesSchema(const C2cRoutesLocalesSchema &) = delete;
  C2cRoutesLocalesSchema(C2cRoutesLocalesSchema &&) = delete;
  C2cRoutesLocalesSchema & operator=(const C2cRoutesLocalesSchema &) = delete;
  C2cRoutesLocalesSchema & operator=(C2cRoutesLocalesSchema &&) = delete;

protected:
  C2cRoutesLocalesSchema();
  ~C2cRoutesLocalesSchema();
};

/**************************************************************************************************/

class C2cRoutesLocales : public QObject, public QoRow<C2cRoutesLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString external_resources READ external_resources WRITE set_external_resources NOTIFY external_resourcesChanged)
  Q_PROPERTY(QString gear READ gear WRITE set_gear NOTIFY gearChanged)
  Q_PROPERTY(QString remarks READ remarks WRITE set_remarks NOTIFY remarksChanged)
  Q_PROPERTY(QString route_history READ route_history WRITE set_route_history NOTIFY route_historyChanged)
  Q_PROPERTY(QString slackline_anchor1 READ slackline_anchor1 WRITE set_slackline_anchor1 NOTIFY slackline_anchor1Changed)
  Q_PROPERTY(QString slackline_anchor2 READ slackline_anchor2 WRITE set_slackline_anchor2 NOTIFY slackline_anchor2Changed)
  Q_PROPERTY(QString slope READ slope WRITE set_slope NOTIFY slopeChanged)
  Q_PROPERTY(QString title_prefix READ title_prefix WRITE set_title_prefix NOTIFY title_prefixChanged)

public:
  typedef C2cRoutesLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cRoutesLocalesPtr;

public:
  C2cRoutesLocales();
  C2cRoutesLocales(const C2cRoutesLocales & other);
  C2cRoutesLocales(const QJsonObject & json_object); // JSON deserializer
  C2cRoutesLocales(const QVariantHash & variant_hash);
  C2cRoutesLocales(const QVariantList & variants);
  C2cRoutesLocales(const QSqlRecord & record); // SQL deserializer
  C2cRoutesLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cRoutesLocales();

  C2cRoutesLocales & operator=(const C2cRoutesLocales & other);

  bool operator==(const C2cRoutesLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & external_resources() const { return m_external_resources; }
  void set_external_resources(const QString & value);

  const QString & gear() const { return m_gear; }
  void set_gear(const QString & value);

  const QString & remarks() const { return m_remarks; }
  void set_remarks(const QString & value);

  const QString & route_history() const { return m_route_history; }
  void set_route_history(const QString & value);

  const QString & slackline_anchor1() const { return m_slackline_anchor1; }
  void set_slackline_anchor1(const QString & value);

  const QString & slackline_anchor2() const { return m_slackline_anchor2; }
  void set_slackline_anchor2(const QString & value);

  const QString & slope() const { return m_slope; }
  void set_slope(const QString & value);

  const QString & title_prefix() const { return m_title_prefix; }
  void set_title_prefix(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_external_resources_modified() const { return bit_status(Schema::Fields::EXTERNAL_RESOURCES); }
  bool is_gear_modified() const { return bit_status(Schema::Fields::GEAR); }
  bool is_remarks_modified() const { return bit_status(Schema::Fields::REMARKS); }
  bool is_route_history_modified() const { return bit_status(Schema::Fields::ROUTE_HISTORY); }
  bool is_slackline_anchor1_modified() const { return bit_status(Schema::Fields::SLACKLINE_ANCHOR1); }
  bool is_slackline_anchor2_modified() const { return bit_status(Schema::Fields::SLACKLINE_ANCHOR2); }
  bool is_slope_modified() const { return bit_status(Schema::Fields::SLOPE); }
  bool is_title_prefix_modified() const { return bit_status(Schema::Fields::TITLE_PREFIX); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void external_resourcesChanged();
  void gearChanged();
  void remarksChanged();
  void route_historyChanged();
  void slackline_anchor1Changed();
  void slackline_anchor2Changed();
  void slopeChanged();
  void title_prefixChanged();

private:
  int m_id;
  QString m_external_resources;
  QString m_gear;
  QString m_remarks;
  QString m_route_history;
  QString m_slackline_anchor1;
  QString m_slackline_anchor2;
  QString m_slope;
  QString m_title_prefix;

};

QDataStream & operator<<(QDataStream & out, const C2cRoutesLocales & obj);
QDataStream & operator>>(QDataStream & in, C2cRoutesLocales & obj);
// qRegisterMetaTypeStreamOperators<C2cRoutesLocales>("C2cRoutesLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cRoutesLocales & obj);
#endif

/**************************************************************************************************/

class C2cRoutesLocalesPtr
{
public:
  typedef C2cRoutesLocales Class;

public:
  C2cRoutesLocalesPtr() : m_ptr() {}
  C2cRoutesLocalesPtr(const C2cRoutesLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cRoutesLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cRoutesLocalesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cRoutesLocalesPtr";
    // m_ptr.clear();
  }

  C2cRoutesLocalesPtr & operator=(const C2cRoutesLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cRoutesLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cRoutesLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cRoutesLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cRoutesLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cRoutesLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cRoutesLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cRoutesLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cRoutesLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cRoutesLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cRoutesLocalesPtr & obj);
#endif

/**************************************************************************************************/

class C2cRoutesLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cRoutesLocales * t_Key;
  typedef C2cRoutesLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cRoutesLocalesCache();
  ~C2cRoutesLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cRoutesLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cRoutesLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cRoutesLocalesModel();
  C2cRoutesLocalesModel(const ItemList & items);
  ~C2cRoutesLocalesModel();

  // Fixme: use C2cRoutesLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    EXTERNAL_RESOURCES,
    GEAR,
    REMARKS,
    ROUTE_HISTORY,
    SLACKLINE_ANCHOR1,
    SLACKLINE_ANCHOR2,
    SLOPE,
    TITLE_PREFIX
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cUser;
class C2cUserPtr;

/**************************************************************************************************/

class C2cUserSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    BLOCKED,
    EMAIL,
    EMAIL_TO_VALIDATE,
    EMAIL_VALIDATED,
    FEED_FILTER_ACTIVITIES,
    FEED_FOLLOWED_ONLY,
    FORUM_USERNAME,
    IS_PROFILE_PUBLIC,
    LANG,
    LAST_MODIFIED,
    MODERATOR,
    NAME,
    PASSWORD,
    USERNAME,
    VALIDATION_NONCE,
    VALIDATION_NONCE_EXPIRE
  };
  static const int NUMBER_OF_FIELDS = 17;

public:
  static C2cUserSchema & instance()
  {
    static C2cUserSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cUserSchema(const C2cUserSchema &) = delete;
  C2cUserSchema(C2cUserSchema &&) = delete;
  C2cUserSchema & operator=(const C2cUserSchema &) = delete;
  C2cUserSchema & operator=(C2cUserSchema &&) = delete;

protected:
  C2cUserSchema();
  ~C2cUserSchema();
};

/**************************************************************************************************/

class C2cUser : public QObject, public QoRow<C2cUserSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(bool blocked READ blocked WRITE set_blocked NOTIFY blockedChanged)
  Q_PROPERTY(QString email READ email WRITE set_email NOTIFY emailChanged)
  Q_PROPERTY(QString email_to_validate READ email_to_validate WRITE set_email_to_validate NOTIFY email_to_validateChanged)
  Q_PROPERTY(bool email_validated READ email_validated WRITE set_email_validated NOTIFY email_validatedChanged)
  Q_PROPERTY(QStringList feed_filter_activities READ feed_filter_activities WRITE set_feed_filter_activities NOTIFY feed_filter_activitiesChanged)
  Q_PROPERTY(bool feed_followed_only READ feed_followed_only WRITE set_feed_followed_only NOTIFY feed_followed_onlyChanged)
  Q_PROPERTY(QString forum_username READ forum_username WRITE set_forum_username NOTIFY forum_usernameChanged)
  Q_PROPERTY(bool is_profile_public READ is_profile_public WRITE set_is_profile_public NOTIFY is_profile_publicChanged)
  Q_PROPERTY(QString lang READ lang WRITE set_lang NOTIFY langChanged)
  Q_PROPERTY(QDateTime last_modified READ last_modified WRITE set_last_modified NOTIFY last_modifiedChanged)
  Q_PROPERTY(bool moderator READ moderator WRITE set_moderator NOTIFY moderatorChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(QString password READ password WRITE set_password NOTIFY passwordChanged)
  Q_PROPERTY(QString username READ username WRITE set_username NOTIFY usernameChanged)
  Q_PROPERTY(QString validation_nonce READ validation_nonce WRITE set_validation_nonce NOTIFY validation_nonceChanged)
  Q_PROPERTY(QDateTime validation_nonce_expire READ validation_nonce_expire WRITE set_validation_nonce_expire NOTIFY validation_nonce_expireChanged)

public:
  typedef C2cUserPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cUserPtr;

public:
  C2cUser();
  C2cUser(const C2cUser & other);
  C2cUser(const QJsonObject & json_object); // JSON deserializer
  C2cUser(const QVariantHash & variant_hash);
  C2cUser(const QVariantList & variants);
  C2cUser(const QSqlRecord & record); // SQL deserializer
  C2cUser(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cUser();

  C2cUser & operator=(const C2cUser & other);

  bool operator==(const C2cUser & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  bool blocked() const { return m_blocked; }
  void set_blocked(bool value);

  const QString & email() const { return m_email; }
  void set_email(const QString & value);

  const QString & email_to_validate() const { return m_email_to_validate; }
  void set_email_to_validate(const QString & value);

  bool email_validated() const { return m_email_validated; }
  void set_email_validated(bool value);

  const QStringList & feed_filter_activities() const { return m_feed_filter_activities; }
  void set_feed_filter_activities(const QStringList & value);

  bool feed_followed_only() const { return m_feed_followed_only; }
  void set_feed_followed_only(bool value);

  const QString & forum_username() const { return m_forum_username; }
  void set_forum_username(const QString & value);

  bool is_profile_public() const { return m_is_profile_public; }
  void set_is_profile_public(bool value);

  const QString & lang() const { return m_lang; }
  void set_lang(const QString & value);

  const QDateTime & last_modified() const { return m_last_modified; }
  void set_last_modified(const QDateTime & value);

  bool moderator() const { return m_moderator; }
  void set_moderator(bool value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  const QString & password() const { return m_password; }
  void set_password(const QString & value);

  const QString & username() const { return m_username; }
  void set_username(const QString & value);

  const QString & validation_nonce() const { return m_validation_nonce; }
  void set_validation_nonce(const QString & value);

  const QDateTime & validation_nonce_expire() const { return m_validation_nonce_expire; }
  void set_validation_nonce_expire(const QDateTime & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_blocked_modified() const { return bit_status(Schema::Fields::BLOCKED); }
  bool is_email_modified() const { return bit_status(Schema::Fields::EMAIL); }
  bool is_email_to_validate_modified() const { return bit_status(Schema::Fields::EMAIL_TO_VALIDATE); }
  bool is_email_validated_modified() const { return bit_status(Schema::Fields::EMAIL_VALIDATED); }
  bool is_feed_filter_activities_modified() const { return bit_status(Schema::Fields::FEED_FILTER_ACTIVITIES); }
  bool is_feed_followed_only_modified() const { return bit_status(Schema::Fields::FEED_FOLLOWED_ONLY); }
  bool is_forum_username_modified() const { return bit_status(Schema::Fields::FORUM_USERNAME); }
  bool is_is_profile_public_modified() const { return bit_status(Schema::Fields::IS_PROFILE_PUBLIC); }
  bool is_lang_modified() const { return bit_status(Schema::Fields::LANG); }
  bool is_last_modified_modified() const { return bit_status(Schema::Fields::LAST_MODIFIED); }
  bool is_moderator_modified() const { return bit_status(Schema::Fields::MODERATOR); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_password_modified() const { return bit_status(Schema::Fields::PASSWORD); }
  bool is_username_modified() const { return bit_status(Schema::Fields::USERNAME); }
  bool is_validation_nonce_modified() const { return bit_status(Schema::Fields::VALIDATION_NONCE); }
  bool is_validation_nonce_expire_modified() const { return bit_status(Schema::Fields::VALIDATION_NONCE_EXPIRE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void blockedChanged();
  void emailChanged();
  void email_to_validateChanged();
  void email_validatedChanged();
  void feed_filter_activitiesChanged();
  void feed_followed_onlyChanged();
  void forum_usernameChanged();
  void is_profile_publicChanged();
  void langChanged();
  void last_modifiedChanged();
  void moderatorChanged();
  void nameChanged();
  void passwordChanged();
  void usernameChanged();
  void validation_nonceChanged();
  void validation_nonce_expireChanged();

private:
  int m_id;
  bool m_blocked;
  QString m_email;
  QString m_email_to_validate;
  bool m_email_validated;
  QStringList m_feed_filter_activities;
  bool m_feed_followed_only;
  QString m_forum_username;
  bool m_is_profile_public;
  QString m_lang;
  QDateTime m_last_modified;
  bool m_moderator;
  QString m_name;
  QString m_password;
  QString m_username;
  QString m_validation_nonce;
  QDateTime m_validation_nonce_expire;

};

QDataStream & operator<<(QDataStream & out, const C2cUser & obj);
QDataStream & operator>>(QDataStream & in, C2cUser & obj);
// qRegisterMetaTypeStreamOperators<C2cUser>("C2cUser");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cUser & obj);
#endif

/**************************************************************************************************/

class C2cUserPtr
{
public:
  typedef C2cUser Class;

public:
  C2cUserPtr() : m_ptr() {}
  C2cUserPtr(const C2cUserPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cUserPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cUserPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cUserPtr";
    // m_ptr.clear();
  }

  C2cUserPtr & operator=(const C2cUserPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cUserPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cUserPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cUserPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cUserPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cUserPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cUserPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cUserPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cUserPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cUserPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cUserPtr & obj);
#endif

/**************************************************************************************************/

class C2cUserCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cUser * t_Key;
  typedef C2cUserPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cUserCache();
  ~C2cUserCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cUserModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cUserPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cUserModel();
  C2cUserModel(const ItemList & items);
  ~C2cUserModel();

  // Fixme: use C2cUserSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    BLOCKED,
    EMAIL,
    EMAIL_TO_VALIDATE,
    EMAIL_VALIDATED,
    FEED_FILTER_ACTIVITIES,
    FEED_FOLLOWED_ONLY,
    FORUM_USERNAME,
    IS_PROFILE_PUBLIC,
    LANG,
    LAST_MODIFIED,
    MODERATOR,
    NAME,
    PASSWORD,
    USERNAME,
    VALIDATION_NONCE,
    VALIDATION_NONCE_EXPIRE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cUserProfiles;
class C2cUserProfilesPtr;

/**************************************************************************************************/

class C2cUserProfilesSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    CATEGORIES
  };
  static const int NUMBER_OF_FIELDS = 3;

public:
  static C2cUserProfilesSchema & instance()
  {
    static C2cUserProfilesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cUserProfilesSchema(const C2cUserProfilesSchema &) = delete;
  C2cUserProfilesSchema(C2cUserProfilesSchema &&) = delete;
  C2cUserProfilesSchema & operator=(const C2cUserProfilesSchema &) = delete;
  C2cUserProfilesSchema & operator=(C2cUserProfilesSchema &&) = delete;

protected:
  C2cUserProfilesSchema();
  ~C2cUserProfilesSchema();
};

/**************************************************************************************************/

class C2cUserProfiles : public QObject, public QoRow<C2cUserProfilesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QStringList categories READ categories WRITE set_categories NOTIFY categoriesChanged)

public:
  typedef C2cUserProfilesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cUserProfilesPtr;

public:
  C2cUserProfiles();
  C2cUserProfiles(const C2cUserProfiles & other);
  C2cUserProfiles(const QJsonObject & json_object); // JSON deserializer
  C2cUserProfiles(const QVariantHash & variant_hash);
  C2cUserProfiles(const QVariantList & variants);
  C2cUserProfiles(const QSqlRecord & record); // SQL deserializer
  C2cUserProfiles(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cUserProfiles();

  C2cUserProfiles & operator=(const C2cUserProfiles & other);

  bool operator==(const C2cUserProfiles & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QStringList & categories() const { return m_categories; }
  void set_categories(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_categories_modified() const { return bit_status(Schema::Fields::CATEGORIES); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void categoriesChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QStringList m_categories;

};

QDataStream & operator<<(QDataStream & out, const C2cUserProfiles & obj);
QDataStream & operator>>(QDataStream & in, C2cUserProfiles & obj);
// qRegisterMetaTypeStreamOperators<C2cUserProfiles>("C2cUserProfiles");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cUserProfiles & obj);
#endif

/**************************************************************************************************/

class C2cUserProfilesPtr
{
public:
  typedef C2cUserProfiles Class;

public:
  C2cUserProfilesPtr() : m_ptr() {}
  C2cUserProfilesPtr(const C2cUserProfilesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cUserProfilesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cUserProfilesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cUserProfilesPtr";
    // m_ptr.clear();
  }

  C2cUserProfilesPtr & operator=(const C2cUserProfilesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cUserProfilesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cUserProfilesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cUserProfilesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cUserProfilesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cUserProfilesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cUserProfilesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cUserProfilesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cUserProfilesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cUserProfilesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cUserProfilesPtr & obj);
#endif

/**************************************************************************************************/

class C2cUserProfilesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cUserProfiles * t_Key;
  typedef C2cUserProfilesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cUserProfilesCache();
  ~C2cUserProfilesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cUserProfilesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cUserProfilesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cUserProfilesModel();
  C2cUserProfilesModel(const ItemList & items);
  ~C2cUserProfilesModel();

  // Fixme: use C2cUserProfilesSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    CATEGORIES
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cWaypoints;
class C2cWaypointsPtr;

/**************************************************************************************************/

class C2cWaypointsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACCESS_TIME,
    BEST_PERIODS,
    BLANKET_UNSTAFFED,
    CAPACITY,
    CAPACITY_STAFFED,
    CHILDREN_PROOF,
    CLIMBING_INDOOR_TYPES,
    CLIMBING_OUTDOOR_TYPES,
    CLIMBING_RATING_MAX,
    CLIMBING_RATING_MEDIAN,
    CLIMBING_RATING_MIN,
    CLIMBING_STYLES,
    CUSTODIANSHIP,
    ELEVATION,
    ELEVATION_MIN,
    EQUIPMENT_RATINGS,
    EXPOSITION_RATING,
    GAS_UNSTAFFED,
    GROUND_TYPES,
    HEATING_UNSTAFFED,
    HEIGHT_MAX,
    HEIGHT_MEDIAN,
    HEIGHT_MIN,
    LENGTH,
    LIFT_ACCESS,
    MAPS_INFO,
    MATRESS_UNSTAFFED,
    ORIENTATIONS,
    PARAGLIDING_RATING,
    PARKING_FEE,
    PHONE,
    PHONE_CUSTODIAN,
    PRODUCT_TYPES,
    PROMINENCE,
    PUBLIC_TRANSPORTATION_RATING,
    PUBLIC_TRANSPORTATION_TYPES,
    RAIN_PROOF,
    ROCK_TYPES,
    ROUTES_QUANTITY,
    SLACKLINE_LENGTH_MAX,
    SLACKLINE_LENGTH_MIN,
    SLACKLINE_TYPES,
    SLOPE,
    SNOW_CLEARANCE_RATING,
    URL,
    WAYPOINT_TYPE,
    WEATHER_STATION_TYPES
  };
  static const int NUMBER_OF_FIELDS = 48;

public:
  static C2cWaypointsSchema & instance()
  {
    static C2cWaypointsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cWaypointsSchema(const C2cWaypointsSchema &) = delete;
  C2cWaypointsSchema(C2cWaypointsSchema &&) = delete;
  C2cWaypointsSchema & operator=(const C2cWaypointsSchema &) = delete;
  C2cWaypointsSchema & operator=(C2cWaypointsSchema &&) = delete;

protected:
  C2cWaypointsSchema();
  ~C2cWaypointsSchema();
};

/**************************************************************************************************/

class C2cWaypoints : public QObject, public QoRow<C2cWaypointsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QString access_time READ access_time WRITE set_access_time NOTIFY access_timeChanged)
  Q_PROPERTY(QStringList best_periods READ best_periods WRITE set_best_periods NOTIFY best_periodsChanged)
  Q_PROPERTY(bool blanket_unstaffed READ blanket_unstaffed WRITE set_blanket_unstaffed NOTIFY blanket_unstaffedChanged)
  Q_PROPERTY(int capacity READ capacity WRITE set_capacity NOTIFY capacityChanged)
  Q_PROPERTY(int capacity_staffed READ capacity_staffed WRITE set_capacity_staffed NOTIFY capacity_staffedChanged)
  Q_PROPERTY(QString children_proof READ children_proof WRITE set_children_proof NOTIFY children_proofChanged)
  Q_PROPERTY(QStringList climbing_indoor_types READ climbing_indoor_types WRITE set_climbing_indoor_types NOTIFY climbing_indoor_typesChanged)
  Q_PROPERTY(QStringList climbing_outdoor_types READ climbing_outdoor_types WRITE set_climbing_outdoor_types NOTIFY climbing_outdoor_typesChanged)
  Q_PROPERTY(QString climbing_rating_max READ climbing_rating_max WRITE set_climbing_rating_max NOTIFY climbing_rating_maxChanged)
  Q_PROPERTY(QString climbing_rating_median READ climbing_rating_median WRITE set_climbing_rating_median NOTIFY climbing_rating_medianChanged)
  Q_PROPERTY(QString climbing_rating_min READ climbing_rating_min WRITE set_climbing_rating_min NOTIFY climbing_rating_minChanged)
  Q_PROPERTY(QStringList climbing_styles READ climbing_styles WRITE set_climbing_styles NOTIFY climbing_stylesChanged)
  Q_PROPERTY(QString custodianship READ custodianship WRITE set_custodianship NOTIFY custodianshipChanged)
  Q_PROPERTY(int elevation READ elevation WRITE set_elevation NOTIFY elevationChanged)
  Q_PROPERTY(int elevation_min READ elevation_min WRITE set_elevation_min NOTIFY elevation_minChanged)
  Q_PROPERTY(QStringList equipment_ratings READ equipment_ratings WRITE set_equipment_ratings NOTIFY equipment_ratingsChanged)
  Q_PROPERTY(QString exposition_rating READ exposition_rating WRITE set_exposition_rating NOTIFY exposition_ratingChanged)
  Q_PROPERTY(bool gas_unstaffed READ gas_unstaffed WRITE set_gas_unstaffed NOTIFY gas_unstaffedChanged)
  Q_PROPERTY(QStringList ground_types READ ground_types WRITE set_ground_types NOTIFY ground_typesChanged)
  Q_PROPERTY(bool heating_unstaffed READ heating_unstaffed WRITE set_heating_unstaffed NOTIFY heating_unstaffedChanged)
  Q_PROPERTY(int height_max READ height_max WRITE set_height_max NOTIFY height_maxChanged)
  Q_PROPERTY(int height_median READ height_median WRITE set_height_median NOTIFY height_medianChanged)
  Q_PROPERTY(int height_min READ height_min WRITE set_height_min NOTIFY height_minChanged)
  Q_PROPERTY(int length READ length WRITE set_length NOTIFY lengthChanged)
  Q_PROPERTY(bool lift_access READ lift_access WRITE set_lift_access NOTIFY lift_accessChanged)
  Q_PROPERTY(QString maps_info READ maps_info WRITE set_maps_info NOTIFY maps_infoChanged)
  Q_PROPERTY(bool matress_unstaffed READ matress_unstaffed WRITE set_matress_unstaffed NOTIFY matress_unstaffedChanged)
  Q_PROPERTY(QStringList orientations READ orientations WRITE set_orientations NOTIFY orientationsChanged)
  Q_PROPERTY(QChar paragliding_rating READ paragliding_rating WRITE set_paragliding_rating NOTIFY paragliding_ratingChanged)
  Q_PROPERTY(QString parking_fee READ parking_fee WRITE set_parking_fee NOTIFY parking_feeChanged)
  Q_PROPERTY(QString phone READ phone WRITE set_phone NOTIFY phoneChanged)
  Q_PROPERTY(QString phone_custodian READ phone_custodian WRITE set_phone_custodian NOTIFY phone_custodianChanged)
  Q_PROPERTY(QStringList product_types READ product_types WRITE set_product_types NOTIFY product_typesChanged)
  Q_PROPERTY(int prominence READ prominence WRITE set_prominence NOTIFY prominenceChanged)
  Q_PROPERTY(QString public_transportation_rating READ public_transportation_rating WRITE set_public_transportation_rating NOTIFY public_transportation_ratingChanged)
  Q_PROPERTY(QStringList public_transportation_types READ public_transportation_types WRITE set_public_transportation_types NOTIFY public_transportation_typesChanged)
  Q_PROPERTY(QString rain_proof READ rain_proof WRITE set_rain_proof NOTIFY rain_proofChanged)
  Q_PROPERTY(QStringList rock_types READ rock_types WRITE set_rock_types NOTIFY rock_typesChanged)
  Q_PROPERTY(int routes_quantity READ routes_quantity WRITE set_routes_quantity NOTIFY routes_quantityChanged)
  Q_PROPERTY(int slackline_length_max READ slackline_length_max WRITE set_slackline_length_max NOTIFY slackline_length_maxChanged)
  Q_PROPERTY(int slackline_length_min READ slackline_length_min WRITE set_slackline_length_min NOTIFY slackline_length_minChanged)
  Q_PROPERTY(QStringList slackline_types READ slackline_types WRITE set_slackline_types NOTIFY slackline_typesChanged)
  Q_PROPERTY(int slope READ slope WRITE set_slope NOTIFY slopeChanged)
  Q_PROPERTY(QString snow_clearance_rating READ snow_clearance_rating WRITE set_snow_clearance_rating NOTIFY snow_clearance_ratingChanged)
  Q_PROPERTY(QString url READ url WRITE set_url NOTIFY urlChanged)
  Q_PROPERTY(QString waypoint_type READ waypoint_type WRITE set_waypoint_type NOTIFY waypoint_typeChanged)
  Q_PROPERTY(QStringList weather_station_types READ weather_station_types WRITE set_weather_station_types NOTIFY weather_station_typesChanged)

public:
  typedef C2cWaypointsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cWaypointsPtr;

public:
  C2cWaypoints();
  C2cWaypoints(const C2cWaypoints & other);
  C2cWaypoints(const QJsonObject & json_object); // JSON deserializer
  C2cWaypoints(const QVariantHash & variant_hash);
  C2cWaypoints(const QVariantList & variants);
  C2cWaypoints(const QSqlRecord & record); // SQL deserializer
  C2cWaypoints(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cWaypoints();

  C2cWaypoints & operator=(const C2cWaypoints & other);

  bool operator==(const C2cWaypoints & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QString & access_time() const { return m_access_time; }
  void set_access_time(const QString & value);

  const QStringList & best_periods() const { return m_best_periods; }
  void set_best_periods(const QStringList & value);

  bool blanket_unstaffed() const { return m_blanket_unstaffed; }
  void set_blanket_unstaffed(bool value);

  int capacity() const { return m_capacity; }
  void set_capacity(int value);

  int capacity_staffed() const { return m_capacity_staffed; }
  void set_capacity_staffed(int value);

  const QString & children_proof() const { return m_children_proof; }
  void set_children_proof(const QString & value);

  const QStringList & climbing_indoor_types() const { return m_climbing_indoor_types; }
  void set_climbing_indoor_types(const QStringList & value);

  const QStringList & climbing_outdoor_types() const { return m_climbing_outdoor_types; }
  void set_climbing_outdoor_types(const QStringList & value);

  const QString & climbing_rating_max() const { return m_climbing_rating_max; }
  void set_climbing_rating_max(const QString & value);

  const QString & climbing_rating_median() const { return m_climbing_rating_median; }
  void set_climbing_rating_median(const QString & value);

  const QString & climbing_rating_min() const { return m_climbing_rating_min; }
  void set_climbing_rating_min(const QString & value);

  const QStringList & climbing_styles() const { return m_climbing_styles; }
  void set_climbing_styles(const QStringList & value);

  const QString & custodianship() const { return m_custodianship; }
  void set_custodianship(const QString & value);

  int elevation() const { return m_elevation; }
  void set_elevation(int value);

  int elevation_min() const { return m_elevation_min; }
  void set_elevation_min(int value);

  const QStringList & equipment_ratings() const { return m_equipment_ratings; }
  void set_equipment_ratings(const QStringList & value);

  const QString & exposition_rating() const { return m_exposition_rating; }
  void set_exposition_rating(const QString & value);

  bool gas_unstaffed() const { return m_gas_unstaffed; }
  void set_gas_unstaffed(bool value);

  const QStringList & ground_types() const { return m_ground_types; }
  void set_ground_types(const QStringList & value);

  bool heating_unstaffed() const { return m_heating_unstaffed; }
  void set_heating_unstaffed(bool value);

  int height_max() const { return m_height_max; }
  void set_height_max(int value);

  int height_median() const { return m_height_median; }
  void set_height_median(int value);

  int height_min() const { return m_height_min; }
  void set_height_min(int value);

  int length() const { return m_length; }
  void set_length(int value);

  bool lift_access() const { return m_lift_access; }
  void set_lift_access(bool value);

  const QString & maps_info() const { return m_maps_info; }
  void set_maps_info(const QString & value);

  bool matress_unstaffed() const { return m_matress_unstaffed; }
  void set_matress_unstaffed(bool value);

  const QStringList & orientations() const { return m_orientations; }
  void set_orientations(const QStringList & value);

  const QChar & paragliding_rating() const { return m_paragliding_rating; }
  void set_paragliding_rating(const QChar & value);

  const QString & parking_fee() const { return m_parking_fee; }
  void set_parking_fee(const QString & value);

  const QString & phone() const { return m_phone; }
  void set_phone(const QString & value);

  const QString & phone_custodian() const { return m_phone_custodian; }
  void set_phone_custodian(const QString & value);

  const QStringList & product_types() const { return m_product_types; }
  void set_product_types(const QStringList & value);

  int prominence() const { return m_prominence; }
  void set_prominence(int value);

  const QString & public_transportation_rating() const { return m_public_transportation_rating; }
  void set_public_transportation_rating(const QString & value);

  const QStringList & public_transportation_types() const { return m_public_transportation_types; }
  void set_public_transportation_types(const QStringList & value);

  const QString & rain_proof() const { return m_rain_proof; }
  void set_rain_proof(const QString & value);

  const QStringList & rock_types() const { return m_rock_types; }
  void set_rock_types(const QStringList & value);

  int routes_quantity() const { return m_routes_quantity; }
  void set_routes_quantity(int value);

  int slackline_length_max() const { return m_slackline_length_max; }
  void set_slackline_length_max(int value);

  int slackline_length_min() const { return m_slackline_length_min; }
  void set_slackline_length_min(int value);

  const QStringList & slackline_types() const { return m_slackline_types; }
  void set_slackline_types(const QStringList & value);

  int slope() const { return m_slope; }
  void set_slope(int value);

  const QString & snow_clearance_rating() const { return m_snow_clearance_rating; }
  void set_snow_clearance_rating(const QString & value);

  const QString & url() const { return m_url; }
  void set_url(const QString & value);

  const QString & waypoint_type() const { return m_waypoint_type; }
  void set_waypoint_type(const QString & value);

  const QStringList & weather_station_types() const { return m_weather_station_types; }
  void set_weather_station_types(const QStringList & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_access_time_modified() const { return bit_status(Schema::Fields::ACCESS_TIME); }
  bool is_best_periods_modified() const { return bit_status(Schema::Fields::BEST_PERIODS); }
  bool is_blanket_unstaffed_modified() const { return bit_status(Schema::Fields::BLANKET_UNSTAFFED); }
  bool is_capacity_modified() const { return bit_status(Schema::Fields::CAPACITY); }
  bool is_capacity_staffed_modified() const { return bit_status(Schema::Fields::CAPACITY_STAFFED); }
  bool is_children_proof_modified() const { return bit_status(Schema::Fields::CHILDREN_PROOF); }
  bool is_climbing_indoor_types_modified() const { return bit_status(Schema::Fields::CLIMBING_INDOOR_TYPES); }
  bool is_climbing_outdoor_types_modified() const { return bit_status(Schema::Fields::CLIMBING_OUTDOOR_TYPES); }
  bool is_climbing_rating_max_modified() const { return bit_status(Schema::Fields::CLIMBING_RATING_MAX); }
  bool is_climbing_rating_median_modified() const { return bit_status(Schema::Fields::CLIMBING_RATING_MEDIAN); }
  bool is_climbing_rating_min_modified() const { return bit_status(Schema::Fields::CLIMBING_RATING_MIN); }
  bool is_climbing_styles_modified() const { return bit_status(Schema::Fields::CLIMBING_STYLES); }
  bool is_custodianship_modified() const { return bit_status(Schema::Fields::CUSTODIANSHIP); }
  bool is_elevation_modified() const { return bit_status(Schema::Fields::ELEVATION); }
  bool is_elevation_min_modified() const { return bit_status(Schema::Fields::ELEVATION_MIN); }
  bool is_equipment_ratings_modified() const { return bit_status(Schema::Fields::EQUIPMENT_RATINGS); }
  bool is_exposition_rating_modified() const { return bit_status(Schema::Fields::EXPOSITION_RATING); }
  bool is_gas_unstaffed_modified() const { return bit_status(Schema::Fields::GAS_UNSTAFFED); }
  bool is_ground_types_modified() const { return bit_status(Schema::Fields::GROUND_TYPES); }
  bool is_heating_unstaffed_modified() const { return bit_status(Schema::Fields::HEATING_UNSTAFFED); }
  bool is_height_max_modified() const { return bit_status(Schema::Fields::HEIGHT_MAX); }
  bool is_height_median_modified() const { return bit_status(Schema::Fields::HEIGHT_MEDIAN); }
  bool is_height_min_modified() const { return bit_status(Schema::Fields::HEIGHT_MIN); }
  bool is_length_modified() const { return bit_status(Schema::Fields::LENGTH); }
  bool is_lift_access_modified() const { return bit_status(Schema::Fields::LIFT_ACCESS); }
  bool is_maps_info_modified() const { return bit_status(Schema::Fields::MAPS_INFO); }
  bool is_matress_unstaffed_modified() const { return bit_status(Schema::Fields::MATRESS_UNSTAFFED); }
  bool is_orientations_modified() const { return bit_status(Schema::Fields::ORIENTATIONS); }
  bool is_paragliding_rating_modified() const { return bit_status(Schema::Fields::PARAGLIDING_RATING); }
  bool is_parking_fee_modified() const { return bit_status(Schema::Fields::PARKING_FEE); }
  bool is_phone_modified() const { return bit_status(Schema::Fields::PHONE); }
  bool is_phone_custodian_modified() const { return bit_status(Schema::Fields::PHONE_CUSTODIAN); }
  bool is_product_types_modified() const { return bit_status(Schema::Fields::PRODUCT_TYPES); }
  bool is_prominence_modified() const { return bit_status(Schema::Fields::PROMINENCE); }
  bool is_public_transportation_rating_modified() const { return bit_status(Schema::Fields::PUBLIC_TRANSPORTATION_RATING); }
  bool is_public_transportation_types_modified() const { return bit_status(Schema::Fields::PUBLIC_TRANSPORTATION_TYPES); }
  bool is_rain_proof_modified() const { return bit_status(Schema::Fields::RAIN_PROOF); }
  bool is_rock_types_modified() const { return bit_status(Schema::Fields::ROCK_TYPES); }
  bool is_routes_quantity_modified() const { return bit_status(Schema::Fields::ROUTES_QUANTITY); }
  bool is_slackline_length_max_modified() const { return bit_status(Schema::Fields::SLACKLINE_LENGTH_MAX); }
  bool is_slackline_length_min_modified() const { return bit_status(Schema::Fields::SLACKLINE_LENGTH_MIN); }
  bool is_slackline_types_modified() const { return bit_status(Schema::Fields::SLACKLINE_TYPES); }
  bool is_slope_modified() const { return bit_status(Schema::Fields::SLOPE); }
  bool is_snow_clearance_rating_modified() const { return bit_status(Schema::Fields::SNOW_CLEARANCE_RATING); }
  bool is_url_modified() const { return bit_status(Schema::Fields::URL); }
  bool is_waypoint_type_modified() const { return bit_status(Schema::Fields::WAYPOINT_TYPE); }
  bool is_weather_station_types_modified() const { return bit_status(Schema::Fields::WEATHER_STATION_TYPES); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void access_timeChanged();
  void best_periodsChanged();
  void blanket_unstaffedChanged();
  void capacityChanged();
  void capacity_staffedChanged();
  void children_proofChanged();
  void climbing_indoor_typesChanged();
  void climbing_outdoor_typesChanged();
  void climbing_rating_maxChanged();
  void climbing_rating_medianChanged();
  void climbing_rating_minChanged();
  void climbing_stylesChanged();
  void custodianshipChanged();
  void elevationChanged();
  void elevation_minChanged();
  void equipment_ratingsChanged();
  void exposition_ratingChanged();
  void gas_unstaffedChanged();
  void ground_typesChanged();
  void heating_unstaffedChanged();
  void height_maxChanged();
  void height_medianChanged();
  void height_minChanged();
  void lengthChanged();
  void lift_accessChanged();
  void maps_infoChanged();
  void matress_unstaffedChanged();
  void orientationsChanged();
  void paragliding_ratingChanged();
  void parking_feeChanged();
  void phoneChanged();
  void phone_custodianChanged();
  void product_typesChanged();
  void prominenceChanged();
  void public_transportation_ratingChanged();
  void public_transportation_typesChanged();
  void rain_proofChanged();
  void rock_typesChanged();
  void routes_quantityChanged();
  void slackline_length_maxChanged();
  void slackline_length_minChanged();
  void slackline_typesChanged();
  void slopeChanged();
  void snow_clearance_ratingChanged();
  void urlChanged();
  void waypoint_typeChanged();
  void weather_station_typesChanged();

private:
  int m_document_id;
  QString m_access_time;
  QStringList m_best_periods;
  bool m_blanket_unstaffed;
  int m_capacity;
  int m_capacity_staffed;
  QString m_children_proof;
  QStringList m_climbing_indoor_types;
  QStringList m_climbing_outdoor_types;
  QString m_climbing_rating_max;
  QString m_climbing_rating_median;
  QString m_climbing_rating_min;
  QStringList m_climbing_styles;
  QString m_custodianship;
  int m_elevation;
  int m_elevation_min;
  QStringList m_equipment_ratings;
  QString m_exposition_rating;
  bool m_gas_unstaffed;
  QStringList m_ground_types;
  bool m_heating_unstaffed;
  int m_height_max;
  int m_height_median;
  int m_height_min;
  int m_length;
  bool m_lift_access;
  QString m_maps_info;
  bool m_matress_unstaffed;
  QStringList m_orientations;
  QChar m_paragliding_rating;
  QString m_parking_fee;
  QString m_phone;
  QString m_phone_custodian;
  QStringList m_product_types;
  int m_prominence;
  QString m_public_transportation_rating;
  QStringList m_public_transportation_types;
  QString m_rain_proof;
  QStringList m_rock_types;
  int m_routes_quantity;
  int m_slackline_length_max;
  int m_slackline_length_min;
  QStringList m_slackline_types;
  int m_slope;
  QString m_snow_clearance_rating;
  QString m_url;
  QString m_waypoint_type;
  QStringList m_weather_station_types;

};

QDataStream & operator<<(QDataStream & out, const C2cWaypoints & obj);
QDataStream & operator>>(QDataStream & in, C2cWaypoints & obj);
// qRegisterMetaTypeStreamOperators<C2cWaypoints>("C2cWaypoints");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cWaypoints & obj);
#endif

/**************************************************************************************************/

class C2cWaypointsPtr
{
public:
  typedef C2cWaypoints Class;

public:
  C2cWaypointsPtr() : m_ptr() {}
  C2cWaypointsPtr(const C2cWaypointsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cWaypointsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cWaypointsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cWaypointsPtr";
    // m_ptr.clear();
  }

  C2cWaypointsPtr & operator=(const C2cWaypointsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cWaypointsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cWaypointsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cWaypointsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cWaypointsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cWaypointsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cWaypointsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cWaypointsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cWaypointsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cWaypointsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cWaypointsPtr & obj);
#endif

/**************************************************************************************************/

class C2cWaypointsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cWaypoints * t_Key;
  typedef C2cWaypointsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cWaypointsCache();
  ~C2cWaypointsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cWaypointsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cWaypointsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cWaypointsModel();
  C2cWaypointsModel(const ItemList & items);
  ~C2cWaypointsModel();

  // Fixme: use C2cWaypointsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACCESS_TIME,
    BEST_PERIODS,
    BLANKET_UNSTAFFED,
    CAPACITY,
    CAPACITY_STAFFED,
    CHILDREN_PROOF,
    CLIMBING_INDOOR_TYPES,
    CLIMBING_OUTDOOR_TYPES,
    CLIMBING_RATING_MAX,
    CLIMBING_RATING_MEDIAN,
    CLIMBING_RATING_MIN,
    CLIMBING_STYLES,
    CUSTODIANSHIP,
    ELEVATION,
    ELEVATION_MIN,
    EQUIPMENT_RATINGS,
    EXPOSITION_RATING,
    GAS_UNSTAFFED,
    GROUND_TYPES,
    HEATING_UNSTAFFED,
    HEIGHT_MAX,
    HEIGHT_MEDIAN,
    HEIGHT_MIN,
    LENGTH,
    LIFT_ACCESS,
    MAPS_INFO,
    MATRESS_UNSTAFFED,
    ORIENTATIONS,
    PARAGLIDING_RATING,
    PARKING_FEE,
    PHONE,
    PHONE_CUSTODIAN,
    PRODUCT_TYPES,
    PROMINENCE,
    PUBLIC_TRANSPORTATION_RATING,
    PUBLIC_TRANSPORTATION_TYPES,
    RAIN_PROOF,
    ROCK_TYPES,
    ROUTES_QUANTITY,
    SLACKLINE_LENGTH_MAX,
    SLACKLINE_LENGTH_MIN,
    SLACKLINE_TYPES,
    SLOPE,
    SNOW_CLEARANCE_RATING,
    URL,
    WAYPOINT_TYPE,
    WEATHER_STATION_TYPES
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cWaypointsLocales;
class C2cWaypointsLocalesPtr;

/**************************************************************************************************/

class C2cWaypointsLocalesSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    ACCESS,
    ACCESS_PERIOD
  };
  static const int NUMBER_OF_FIELDS = 3;

public:
  static C2cWaypointsLocalesSchema & instance()
  {
    static C2cWaypointsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cWaypointsLocalesSchema(const C2cWaypointsLocalesSchema &) = delete;
  C2cWaypointsLocalesSchema(C2cWaypointsLocalesSchema &&) = delete;
  C2cWaypointsLocalesSchema & operator=(const C2cWaypointsLocalesSchema &) = delete;
  C2cWaypointsLocalesSchema & operator=(C2cWaypointsLocalesSchema &&) = delete;

protected:
  C2cWaypointsLocalesSchema();
  ~C2cWaypointsLocalesSchema();
};

/**************************************************************************************************/

class C2cWaypointsLocales : public QObject, public QoRow<C2cWaypointsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString access READ access WRITE set_access NOTIFY accessChanged)
  Q_PROPERTY(QString access_period READ access_period WRITE set_access_period NOTIFY access_periodChanged)

public:
  typedef C2cWaypointsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cWaypointsLocalesPtr;

public:
  C2cWaypointsLocales();
  C2cWaypointsLocales(const C2cWaypointsLocales & other);
  C2cWaypointsLocales(const QJsonObject & json_object); // JSON deserializer
  C2cWaypointsLocales(const QVariantHash & variant_hash);
  C2cWaypointsLocales(const QVariantList & variants);
  C2cWaypointsLocales(const QSqlRecord & record); // SQL deserializer
  C2cWaypointsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cWaypointsLocales();

  C2cWaypointsLocales & operator=(const C2cWaypointsLocales & other);

  bool operator==(const C2cWaypointsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & access() const { return m_access; }
  void set_access(const QString & value);

  const QString & access_period() const { return m_access_period; }
  void set_access_period(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_access_modified() const { return bit_status(Schema::Fields::ACCESS); }
  bool is_access_period_modified() const { return bit_status(Schema::Fields::ACCESS_PERIOD); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void accessChanged();
  void access_periodChanged();

private:
  int m_id;
  QString m_access;
  QString m_access_period;

};

QDataStream & operator<<(QDataStream & out, const C2cWaypointsLocales & obj);
QDataStream & operator>>(QDataStream & in, C2cWaypointsLocales & obj);
// qRegisterMetaTypeStreamOperators<C2cWaypointsLocales>("C2cWaypointsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cWaypointsLocales & obj);
#endif

/**************************************************************************************************/

class C2cWaypointsLocalesPtr
{
public:
  typedef C2cWaypointsLocales Class;

public:
  C2cWaypointsLocalesPtr() : m_ptr() {}
  C2cWaypointsLocalesPtr(const C2cWaypointsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cWaypointsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cWaypointsLocalesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cWaypointsLocalesPtr";
    // m_ptr.clear();
  }

  C2cWaypointsLocalesPtr & operator=(const C2cWaypointsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cWaypointsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cWaypointsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cWaypointsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cWaypointsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cWaypointsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cWaypointsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cWaypointsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cWaypointsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cWaypointsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cWaypointsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class C2cWaypointsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cWaypointsLocales * t_Key;
  typedef C2cWaypointsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cWaypointsLocalesCache();
  ~C2cWaypointsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cWaypointsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cWaypointsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cWaypointsLocalesModel();
  C2cWaypointsLocalesModel(const ItemList & items);
  ~C2cWaypointsLocalesModel();

  // Fixme: use C2cWaypointsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    ACCESS,
    ACCESS_PERIOD
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cXreports;
class C2cXreportsPtr;

/**************************************************************************************************/

class C2cXreportsSchema : public QoSchema
{
public:
  enum Fields {
    DOCUMENT_ID,
    ACTIVITIES,
    ACTIVITY_RATE,
    AGE,
    AUTHOR_STATUS,
    AUTONOMY,
    AVALANCHE_LEVEL,
    AVALANCHE_SLOPE,
    DATE,
    DISABLE_COMMENTS,
    ELEVATION,
    EVENT_TYPE,
    GENDER,
    NB_IMPACTED,
    NB_OUTINGS,
    NB_PARTICIPANTS,
    PREVIOUS_INJURIES,
    RESCUE,
    SEVERITY
  };
  static const int NUMBER_OF_FIELDS = 19;

public:
  static C2cXreportsSchema & instance()
  {
    static C2cXreportsSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cXreportsSchema(const C2cXreportsSchema &) = delete;
  C2cXreportsSchema(C2cXreportsSchema &&) = delete;
  C2cXreportsSchema & operator=(const C2cXreportsSchema &) = delete;
  C2cXreportsSchema & operator=(C2cXreportsSchema &&) = delete;

protected:
  C2cXreportsSchema();
  ~C2cXreportsSchema();
};

/**************************************************************************************************/

class C2cXreports : public QObject, public QoRow<C2cXreportsSchema>
{
  Q_OBJECT
  Q_PROPERTY(int document_id READ document_id WRITE set_document_id NOTIFY document_idChanged)
  Q_PROPERTY(QStringList activities READ activities WRITE set_activities NOTIFY activitiesChanged)
  Q_PROPERTY(QString activity_rate READ activity_rate WRITE set_activity_rate NOTIFY activity_rateChanged)
  Q_PROPERTY(int age READ age WRITE set_age NOTIFY ageChanged)
  Q_PROPERTY(QString author_status READ author_status WRITE set_author_status NOTIFY author_statusChanged)
  Q_PROPERTY(QString autonomy READ autonomy WRITE set_autonomy NOTIFY autonomyChanged)
  Q_PROPERTY(QString avalanche_level READ avalanche_level WRITE set_avalanche_level NOTIFY avalanche_levelChanged)
  Q_PROPERTY(QString avalanche_slope READ avalanche_slope WRITE set_avalanche_slope NOTIFY avalanche_slopeChanged)
  Q_PROPERTY(QDate date READ date WRITE set_date NOTIFY dateChanged)
  Q_PROPERTY(bool disable_comments READ disable_comments WRITE set_disable_comments NOTIFY disable_commentsChanged)
  Q_PROPERTY(int elevation READ elevation WRITE set_elevation NOTIFY elevationChanged)
  Q_PROPERTY(QStringList event_type READ event_type WRITE set_event_type NOTIFY event_typeChanged)
  Q_PROPERTY(QString gender READ gender WRITE set_gender NOTIFY genderChanged)
  Q_PROPERTY(int nb_impacted READ nb_impacted WRITE set_nb_impacted NOTIFY nb_impactedChanged)
  Q_PROPERTY(QString nb_outings READ nb_outings WRITE set_nb_outings NOTIFY nb_outingsChanged)
  Q_PROPERTY(int nb_participants READ nb_participants WRITE set_nb_participants NOTIFY nb_participantsChanged)
  Q_PROPERTY(QString previous_injuries READ previous_injuries WRITE set_previous_injuries NOTIFY previous_injuriesChanged)
  Q_PROPERTY(bool rescue READ rescue WRITE set_rescue NOTIFY rescueChanged)
  Q_PROPERTY(QString severity READ severity WRITE set_severity NOTIFY severityChanged)

public:
  typedef C2cXreportsPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cXreportsPtr;

public:
  C2cXreports();
  C2cXreports(const C2cXreports & other);
  C2cXreports(const QJsonObject & json_object); // JSON deserializer
  C2cXreports(const QVariantHash & variant_hash);
  C2cXreports(const QVariantList & variants);
  C2cXreports(const QSqlRecord & record); // SQL deserializer
  C2cXreports(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cXreports();

  C2cXreports & operator=(const C2cXreports & other);

  bool operator==(const C2cXreports & other) const;

  // Getter/Setter

  int document_id() const { return m_document_id; }
  void set_document_id(int value);

  const QStringList & activities() const { return m_activities; }
  void set_activities(const QStringList & value);

  const QString & activity_rate() const { return m_activity_rate; }
  void set_activity_rate(const QString & value);

  int age() const { return m_age; }
  void set_age(int value);

  const QString & author_status() const { return m_author_status; }
  void set_author_status(const QString & value);

  const QString & autonomy() const { return m_autonomy; }
  void set_autonomy(const QString & value);

  const QString & avalanche_level() const { return m_avalanche_level; }
  void set_avalanche_level(const QString & value);

  const QString & avalanche_slope() const { return m_avalanche_slope; }
  void set_avalanche_slope(const QString & value);

  const QDate & date() const { return m_date; }
  void set_date(const QDate & value);

  bool disable_comments() const { return m_disable_comments; }
  void set_disable_comments(bool value);

  int elevation() const { return m_elevation; }
  void set_elevation(int value);

  const QStringList & event_type() const { return m_event_type; }
  void set_event_type(const QStringList & value);

  const QString & gender() const { return m_gender; }
  void set_gender(const QString & value);

  int nb_impacted() const { return m_nb_impacted; }
  void set_nb_impacted(int value);

  const QString & nb_outings() const { return m_nb_outings; }
  void set_nb_outings(const QString & value);

  int nb_participants() const { return m_nb_participants; }
  void set_nb_participants(int value);

  const QString & previous_injuries() const { return m_previous_injuries; }
  void set_previous_injuries(const QString & value);

  bool rescue() const { return m_rescue; }
  void set_rescue(bool value);

  const QString & severity() const { return m_severity; }
  void set_severity(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_document_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_document_id_modified() const { return bit_status(Schema::Fields::DOCUMENT_ID); }
  bool is_activities_modified() const { return bit_status(Schema::Fields::ACTIVITIES); }
  bool is_activity_rate_modified() const { return bit_status(Schema::Fields::ACTIVITY_RATE); }
  bool is_age_modified() const { return bit_status(Schema::Fields::AGE); }
  bool is_author_status_modified() const { return bit_status(Schema::Fields::AUTHOR_STATUS); }
  bool is_autonomy_modified() const { return bit_status(Schema::Fields::AUTONOMY); }
  bool is_avalanche_level_modified() const { return bit_status(Schema::Fields::AVALANCHE_LEVEL); }
  bool is_avalanche_slope_modified() const { return bit_status(Schema::Fields::AVALANCHE_SLOPE); }
  bool is_date_modified() const { return bit_status(Schema::Fields::DATE); }
  bool is_disable_comments_modified() const { return bit_status(Schema::Fields::DISABLE_COMMENTS); }
  bool is_elevation_modified() const { return bit_status(Schema::Fields::ELEVATION); }
  bool is_event_type_modified() const { return bit_status(Schema::Fields::EVENT_TYPE); }
  bool is_gender_modified() const { return bit_status(Schema::Fields::GENDER); }
  bool is_nb_impacted_modified() const { return bit_status(Schema::Fields::NB_IMPACTED); }
  bool is_nb_outings_modified() const { return bit_status(Schema::Fields::NB_OUTINGS); }
  bool is_nb_participants_modified() const { return bit_status(Schema::Fields::NB_PARTICIPANTS); }
  bool is_previous_injuries_modified() const { return bit_status(Schema::Fields::PREVIOUS_INJURIES); }
  bool is_rescue_modified() const { return bit_status(Schema::Fields::RESCUE); }
  bool is_severity_modified() const { return bit_status(Schema::Fields::SEVERITY); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void document_idChanged();
  void activitiesChanged();
  void activity_rateChanged();
  void ageChanged();
  void author_statusChanged();
  void autonomyChanged();
  void avalanche_levelChanged();
  void avalanche_slopeChanged();
  void dateChanged();
  void disable_commentsChanged();
  void elevationChanged();
  void event_typeChanged();
  void genderChanged();
  void nb_impactedChanged();
  void nb_outingsChanged();
  void nb_participantsChanged();
  void previous_injuriesChanged();
  void rescueChanged();
  void severityChanged();

private:
  int m_document_id;
  QStringList m_activities;
  QString m_activity_rate;
  int m_age;
  QString m_author_status;
  QString m_autonomy;
  QString m_avalanche_level;
  QString m_avalanche_slope;
  QDate m_date;
  bool m_disable_comments;
  int m_elevation;
  QStringList m_event_type;
  QString m_gender;
  int m_nb_impacted;
  QString m_nb_outings;
  int m_nb_participants;
  QString m_previous_injuries;
  bool m_rescue;
  QString m_severity;

};

QDataStream & operator<<(QDataStream & out, const C2cXreports & obj);
QDataStream & operator>>(QDataStream & in, C2cXreports & obj);
// qRegisterMetaTypeStreamOperators<C2cXreports>("C2cXreports");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cXreports & obj);
#endif

/**************************************************************************************************/

class C2cXreportsPtr
{
public:
  typedef C2cXreports Class;

public:
  C2cXreportsPtr() : m_ptr() {}
  C2cXreportsPtr(const C2cXreportsPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cXreportsPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cXreportsPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cXreportsPtr";
    // m_ptr.clear();
  }

  C2cXreportsPtr & operator=(const C2cXreportsPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cXreportsPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cXreportsPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cXreportsPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cXreportsPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cXreportsPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cXreportsPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cXreportsPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cXreportsPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cXreportsPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cXreportsPtr & obj);
#endif

/**************************************************************************************************/

class C2cXreportsCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cXreports * t_Key;
  typedef C2cXreportsPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cXreportsCache();
  ~C2cXreportsCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cXreportsModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cXreportsPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cXreportsModel();
  C2cXreportsModel(const ItemList & items);
  ~C2cXreportsModel();

  // Fixme: use C2cXreportsSchema::Fields ???
  enum Roles {
    DOCUMENT_ID = Qt::UserRole + 1,
    ACTIVITIES,
    ACTIVITY_RATE,
    AGE,
    AUTHOR_STATUS,
    AUTONOMY,
    AVALANCHE_LEVEL,
    AVALANCHE_SLOPE,
    DATE,
    DISABLE_COMMENTS,
    ELEVATION,
    EVENT_TYPE,
    GENDER,
    NB_IMPACTED,
    NB_OUTINGS,
    NB_PARTICIPANTS,
    PREVIOUS_INJURIES,
    RESCUE,
    SEVERITY
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2cXreportsLocales;
class C2cXreportsLocalesPtr;

/**************************************************************************************************/

class C2cXreportsLocalesSchema : public QoSchema
{
public:
  enum Fields {
    ID,
    CONDITIONS,
    GROUP_MANAGEMENT,
    INCREASE_IMPACT,
    MODIFICATIONS,
    MOTIVATIONS,
    OTHER_COMMENTS,
    PLACE,
    REDUCE_IMPACT,
    RISK,
    ROUTE_STUDY,
    SAFETY,
    TIME_MANAGEMENT,
    TRAINING
  };
  static const int NUMBER_OF_FIELDS = 14;

public:
  static C2cXreportsLocalesSchema & instance()
  {
    static C2cXreportsLocalesSchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  C2cXreportsLocalesSchema(const C2cXreportsLocalesSchema &) = delete;
  C2cXreportsLocalesSchema(C2cXreportsLocalesSchema &&) = delete;
  C2cXreportsLocalesSchema & operator=(const C2cXreportsLocalesSchema &) = delete;
  C2cXreportsLocalesSchema & operator=(C2cXreportsLocalesSchema &&) = delete;

protected:
  C2cXreportsLocalesSchema();
  ~C2cXreportsLocalesSchema();
};

/**************************************************************************************************/

class C2cXreportsLocales : public QObject, public QoRow<C2cXreportsLocalesSchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString conditions READ conditions WRITE set_conditions NOTIFY conditionsChanged)
  Q_PROPERTY(QString group_management READ group_management WRITE set_group_management NOTIFY group_managementChanged)
  Q_PROPERTY(QString increase_impact READ increase_impact WRITE set_increase_impact NOTIFY increase_impactChanged)
  Q_PROPERTY(QString modifications READ modifications WRITE set_modifications NOTIFY modificationsChanged)
  Q_PROPERTY(QString motivations READ motivations WRITE set_motivations NOTIFY motivationsChanged)
  Q_PROPERTY(QString other_comments READ other_comments WRITE set_other_comments NOTIFY other_commentsChanged)
  Q_PROPERTY(QString place READ place WRITE set_place NOTIFY placeChanged)
  Q_PROPERTY(QString reduce_impact READ reduce_impact WRITE set_reduce_impact NOTIFY reduce_impactChanged)
  Q_PROPERTY(QString risk READ risk WRITE set_risk NOTIFY riskChanged)
  Q_PROPERTY(QString route_study READ route_study WRITE set_route_study NOTIFY route_studyChanged)
  Q_PROPERTY(QString safety READ safety WRITE set_safety NOTIFY safetyChanged)
  Q_PROPERTY(QString time_management READ time_management WRITE set_time_management NOTIFY time_managementChanged)
  Q_PROPERTY(QString training READ training WRITE set_training NOTIFY trainingChanged)

public:
  typedef C2cXreportsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class C2cXreportsLocalesPtr;

public:
  C2cXreportsLocales();
  C2cXreportsLocales(const C2cXreportsLocales & other);
  C2cXreportsLocales(const QJsonObject & json_object); // JSON deserializer
  C2cXreportsLocales(const QVariantHash & variant_hash);
  C2cXreportsLocales(const QVariantList & variants);
  C2cXreportsLocales(const QSqlRecord & record); // SQL deserializer
  C2cXreportsLocales(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~C2cXreportsLocales();

  C2cXreportsLocales & operator=(const C2cXreportsLocales & other);

  bool operator==(const C2cXreportsLocales & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & conditions() const { return m_conditions; }
  void set_conditions(const QString & value);

  const QString & group_management() const { return m_group_management; }
  void set_group_management(const QString & value);

  const QString & increase_impact() const { return m_increase_impact; }
  void set_increase_impact(const QString & value);

  const QString & modifications() const { return m_modifications; }
  void set_modifications(const QString & value);

  const QString & motivations() const { return m_motivations; }
  void set_motivations(const QString & value);

  const QString & other_comments() const { return m_other_comments; }
  void set_other_comments(const QString & value);

  const QString & place() const { return m_place; }
  void set_place(const QString & value);

  const QString & reduce_impact() const { return m_reduce_impact; }
  void set_reduce_impact(const QString & value);

  const QString & risk() const { return m_risk; }
  void set_risk(const QString & value);

  const QString & route_study() const { return m_route_study; }
  void set_route_study(const QString & value);

  const QString & safety() const { return m_safety; }
  void set_safety(const QString & value);

  const QString & time_management() const { return m_time_management; }
  void set_time_management(const QString & value);

  const QString & training() const { return m_training; }
  void set_training(const QString & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_conditions_modified() const { return bit_status(Schema::Fields::CONDITIONS); }
  bool is_group_management_modified() const { return bit_status(Schema::Fields::GROUP_MANAGEMENT); }
  bool is_increase_impact_modified() const { return bit_status(Schema::Fields::INCREASE_IMPACT); }
  bool is_modifications_modified() const { return bit_status(Schema::Fields::MODIFICATIONS); }
  bool is_motivations_modified() const { return bit_status(Schema::Fields::MOTIVATIONS); }
  bool is_other_comments_modified() const { return bit_status(Schema::Fields::OTHER_COMMENTS); }
  bool is_place_modified() const { return bit_status(Schema::Fields::PLACE); }
  bool is_reduce_impact_modified() const { return bit_status(Schema::Fields::REDUCE_IMPACT); }
  bool is_risk_modified() const { return bit_status(Schema::Fields::RISK); }
  bool is_route_study_modified() const { return bit_status(Schema::Fields::ROUTE_STUDY); }
  bool is_safety_modified() const { return bit_status(Schema::Fields::SAFETY); }
  bool is_time_management_modified() const { return bit_status(Schema::Fields::TIME_MANAGEMENT); }
  bool is_training_modified() const { return bit_status(Schema::Fields::TRAINING); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void conditionsChanged();
  void group_managementChanged();
  void increase_impactChanged();
  void modificationsChanged();
  void motivationsChanged();
  void other_commentsChanged();
  void placeChanged();
  void reduce_impactChanged();
  void riskChanged();
  void route_studyChanged();
  void safetyChanged();
  void time_managementChanged();
  void trainingChanged();

private:
  int m_id;
  QString m_conditions;
  QString m_group_management;
  QString m_increase_impact;
  QString m_modifications;
  QString m_motivations;
  QString m_other_comments;
  QString m_place;
  QString m_reduce_impact;
  QString m_risk;
  QString m_route_study;
  QString m_safety;
  QString m_time_management;
  QString m_training;

};

QDataStream & operator<<(QDataStream & out, const C2cXreportsLocales & obj);
QDataStream & operator>>(QDataStream & in, C2cXreportsLocales & obj);
// qRegisterMetaTypeStreamOperators<C2cXreportsLocales>("C2cXreportsLocales");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cXreportsLocales & obj);
#endif

/**************************************************************************************************/

class C2cXreportsLocalesPtr
{
public:
  typedef C2cXreportsLocales Class;

public:
  C2cXreportsLocalesPtr() : m_ptr() {}
  C2cXreportsLocalesPtr(const C2cXreportsLocalesPtr & other) : m_ptr(other.m_ptr) {}
  ~C2cXreportsLocalesPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete C2cXreportsLocalesPtr of" << *m_ptr;
    // qATInfo() << "--- Delete C2cXreportsLocalesPtr";
    // m_ptr.clear();
  }

  C2cXreportsLocalesPtr & operator=(const C2cXreportsLocalesPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  C2cXreportsLocalesPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  C2cXreportsLocalesPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  C2cXreportsLocalesPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  C2cXreportsLocalesPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  C2cXreportsLocalesPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  C2cXreportsLocalesPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  C2cXreportsLocalesPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const C2cXreportsLocalesPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const C2cXreportsLocalesPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const C2cXreportsLocalesPtr & obj);
#endif

/**************************************************************************************************/

class C2cXreportsLocalesCache : public QObject
{
  Q_OBJECT

public:
  typedef C2cXreportsLocales * t_Key;
  typedef C2cXreportsLocalesPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  C2cXreportsLocalesCache();
  ~C2cXreportsLocalesCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class C2cXreportsLocalesModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef C2cXreportsLocalesPtr Item;
  typedef QList<Item> ItemList;

public:
  C2cXreportsLocalesModel();
  C2cXreportsLocalesModel(const ItemList & items);
  ~C2cXreportsLocalesModel();

  // Fixme: use C2cXreportsLocalesSchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    CONDITIONS,
    GROUP_MANAGEMENT,
    INCREASE_IMPACT,
    MODIFICATIONS,
    MOTIVATIONS,
    OTHER_COMMENTS,
    PLACE,
    REDUCE_IMPACT,
    RISK,
    ROUTE_STUDY,
    SAFETY,
    TIME_MANAGEMENT,
    TRAINING
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class C2c : public QoDatabaseSchema
{
public:
  C2c(QoDatabase & database);
  C2c(const C2c & other) = delete;
  ~C2c();

  C2c & operator=(const C2c & other) = delete;

  QoDatabaseTable & c2c_area_associations() { return *m_c2c_area_associations; }
  QoDatabaseTable & c2c_areas() { return *m_c2c_areas; }
  QoDatabaseTable & c2c_articles() { return *m_c2c_articles; }
  QoDatabaseTable & c2c_associations() { return *m_c2c_associations; }
  QoDatabaseTable & c2c_books() { return *m_c2c_books; }
  QoDatabaseTable & c2c_documents() { return *m_c2c_documents; }
  QoDatabaseTable & c2c_documents_geometries() { return *m_c2c_documents_geometries; }
  QoDatabaseTable & c2c_documents_locales() { return *m_c2c_documents_locales; }
  QoDatabaseTable & c2c_documents_topics() { return *m_c2c_documents_topics; }
  QoDatabaseTable & c2c_documents_versions() { return *m_c2c_documents_versions; }
  QoDatabaseTable & c2c_images() { return *m_c2c_images; }
  QoDatabaseTable & c2c_map_associations() { return *m_c2c_map_associations; }
  QoDatabaseTable & c2c_maps() { return *m_c2c_maps; }
  QoDatabaseTable & c2c_outings() { return *m_c2c_outings; }
  QoDatabaseTable & c2c_outings_locales() { return *m_c2c_outings_locales; }
  QoDatabaseTable & c2c_routes() { return *m_c2c_routes; }
  QoDatabaseTable & c2c_routes_locales() { return *m_c2c_routes_locales; }
  QoDatabaseTable & c2c_user() { return *m_c2c_user; }
  QoDatabaseTable & c2c_user_profiles() { return *m_c2c_user_profiles; }
  QoDatabaseTable & c2c_waypoints() { return *m_c2c_waypoints; }
  QoDatabaseTable & c2c_waypoints_locales() { return *m_c2c_waypoints_locales; }
  QoDatabaseTable & c2c_xreports() { return *m_c2c_xreports; }
  QoDatabaseTable & c2c_xreports_locales() { return *m_c2c_xreports_locales; }

private:
  template<class T> void register_row(typename T::Ptr & row);

private:
  QoDatabaseTable * m_c2c_area_associations;
  QoDatabaseTable * m_c2c_areas;
  QoDatabaseTable * m_c2c_articles;
  QoDatabaseTable * m_c2c_associations;
  QoDatabaseTable * m_c2c_books;
  QoDatabaseTable * m_c2c_documents;
  QoDatabaseTable * m_c2c_documents_geometries;
  QoDatabaseTable * m_c2c_documents_locales;
  QoDatabaseTable * m_c2c_documents_topics;
  QoDatabaseTable * m_c2c_documents_versions;
  QoDatabaseTable * m_c2c_images;
  QoDatabaseTable * m_c2c_map_associations;
  QoDatabaseTable * m_c2c_maps;
  QoDatabaseTable * m_c2c_outings;
  QoDatabaseTable * m_c2c_outings_locales;
  QoDatabaseTable * m_c2c_routes;
  QoDatabaseTable * m_c2c_routes_locales;
  QoDatabaseTable * m_c2c_user;
  QoDatabaseTable * m_c2c_user_profiles;
  QoDatabaseTable * m_c2c_waypoints;
  QoDatabaseTable * m_c2c_waypoints_locales;
  QoDatabaseTable * m_c2c_xreports;
  QoDatabaseTable * m_c2c_xreports_locales;
  C2cAreaAssociationsCache m_c2c_area_associations_cache;
  C2cAreasCache m_c2c_areas_cache;
  C2cArticlesCache m_c2c_articles_cache;
  C2cAssociationsCache m_c2c_associations_cache;
  C2cBooksCache m_c2c_books_cache;
  C2cDocumentsCache m_c2c_documents_cache;
  C2cDocumentsGeometriesCache m_c2c_documents_geometries_cache;
  C2cDocumentsLocalesCache m_c2c_documents_locales_cache;
  C2cDocumentsTopicsCache m_c2c_documents_topics_cache;
  C2cDocumentsVersionsCache m_c2c_documents_versions_cache;
  C2cImagesCache m_c2c_images_cache;
  C2cMapAssociationsCache m_c2c_map_associations_cache;
  C2cMapsCache m_c2c_maps_cache;
  C2cOutingsCache m_c2c_outings_cache;
  C2cOutingsLocalesCache m_c2c_outings_locales_cache;
  C2cRoutesCache m_c2c_routes_cache;
  C2cRoutesLocalesCache m_c2c_routes_locales_cache;
  C2cUserCache m_c2c_user_cache;
  C2cUserProfilesCache m_c2c_user_profiles_cache;
  C2cWaypointsCache m_c2c_waypoints_cache;
  C2cWaypointsLocalesCache m_c2c_waypoints_locales_cache;
  C2cXreportsCache m_c2c_xreports_cache;
  C2cXreportsLocalesCache m_c2c_xreports_locales_cache;
};

/**************************************************************************************************/
#endif /* __CAMPTOCAMP_SCHEMA_H__ */