// -*- mode: c++ -*-
// This file was automatically generated by SqlOrm

/***************************************************************************************************
 *
 * $ALPINE_TOOLKIT_BEGIN_LICENSE:GPL3$
 *
 * Copyright (C) 2017 Fabrice Salvaire
 * Contact: http://www.fabrice-salvaire.fr
 *
 * This file is part of the Alpine Toolkit software.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * $ALPINE_TOOLKIT_END_LICENSE$
 *
 **************************************************************************************************/

/**************************************************************************************************/

#ifndef __SETTINGS_SCHEMA_H__
#define __SETTINGS_SCHEMA_H__

/**************************************************************************************************/

#define QT_SHAREDPOINTER_TRACK_POINTERS // For dubug purpose

#include "alpine_toolkit.h"
#include "orm/database_row.h"
#include "orm/database_row_list.h"
#include "orm/database_schema.h"
#include "orm/schema.h"

#include <QAbstractListModel>
#include <QDataStream>
#include <QJsonObject>
#include <QMap>
#include <QSharedPointer>
#include <QSqlQuery>
#include <QSqlRecord>
#include <QString>
#include <QtDebug>
#include <QVariant>
#include <QVariantList>

/**************************************************************************************************/

class Directory;
class DirectoryPtr;

class Key;
class KeyPtr;

/**************************************************************************************************/

class DirectorySchema : public QoSchema
{
public:
  enum Fields {
    ID,
    NAME,
    PARENT
  };
  static const int NUMBER_OF_FIELDS = 3;

public:
  static DirectorySchema & instance()
  {
    static DirectorySchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  DirectorySchema(const DirectorySchema &) = delete;
  DirectorySchema(DirectorySchema &&) = delete;
  DirectorySchema & operator=(const DirectorySchema &) = delete;
  DirectorySchema & operator=(DirectorySchema &&) = delete;

protected:
  DirectorySchema();
  ~DirectorySchema();
};

/**************************************************************************************************/

class Directory : public QObject, public QoRow<DirectorySchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(int parent READ parent WRITE set_parent NOTIFY parentChanged)

public:
  typedef DirectoryPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class DirectoryPtr;

public:
  Directory();
  Directory(const Directory & other);
  Directory(const QJsonObject & json_object); // JSON deserializer
  Directory(const QVariantHash & variant_hash);
  Directory(const QVariantList & variants);
  Directory(const QSqlRecord & record); // SQL deserializer
  Directory(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Directory();

  Directory & operator=(const Directory & other);

  bool operator==(const Directory & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  int parent() const { return m_parent; }
  void set_parent(int value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_parent_modified() const { return bit_status(Schema::Fields::PARENT); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_save() const;

  void load_relations();
  void save_relations();

  QoRowList<Key, KeyPtr> & keys() { return m_keys; }

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void nameChanged();
  void parentChanged();

private:
  int m_id;
  QString m_name;
  int m_parent;
  QoRowList<Key, KeyPtr> m_keys;

};

QDataStream & operator<<(QDataStream & out, const Directory & obj);
QDataStream & operator>>(QDataStream & in, Directory & obj);
// qRegisterMetaTypeStreamOperators<Directory>("Directory");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Directory & obj);
#endif

/**************************************************************************************************/

class DirectoryPtr
{
public:
  typedef Directory Class;

public:
  DirectoryPtr() : m_ptr() {}
  DirectoryPtr(const DirectoryPtr & other) : m_ptr(other.m_ptr) {}
  ~DirectoryPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete DirectoryPtr of" << *m_ptr;
    // qATInfo() << "--- Delete DirectoryPtr";
    // m_ptr.clear();
  }

  DirectoryPtr & operator=(const DirectoryPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  DirectoryPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  DirectoryPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  DirectoryPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  DirectoryPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  DirectoryPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  DirectoryPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  DirectoryPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const DirectoryPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const DirectoryPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const DirectoryPtr & obj);
#endif

/**************************************************************************************************/

class DirectoryCache : public QObject
{
  Q_OBJECT

public:
  typedef Directory * t_Key;
  typedef DirectoryPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  DirectoryCache();
  ~DirectoryCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class DirectoryModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef DirectoryPtr Item;
  typedef QList<Item> ItemList;

public:
  DirectoryModel();
  DirectoryModel(const ItemList & items);
  ~DirectoryModel();

  // Fixme: use DirectorySchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    NAME,
    PARENT
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class Key;
class KeyPtr;

/**************************************************************************************************/

class KeySchema : public QoSchema
{
public:
  enum Fields {
    ID,
    NAME,
    DIRECTORY_ID,
    VALUE
  };
  static const int NUMBER_OF_FIELDS = 4;

public:
  static KeySchema & instance()
  {
    static KeySchema m_instance;
    return m_instance;
  }

  // delete copy and move constructors and assign operators
  KeySchema(const KeySchema &) = delete;
  KeySchema(KeySchema &&) = delete;
  KeySchema & operator=(const KeySchema &) = delete;
  KeySchema & operator=(KeySchema &&) = delete;

protected:
  KeySchema();
  ~KeySchema();
};

/**************************************************************************************************/

class Key : public QObject, public QoRow<KeySchema>
{
  Q_OBJECT
  Q_PROPERTY(int id READ id WRITE set_id NOTIFY idChanged)
  Q_PROPERTY(QString name READ name WRITE set_name NOTIFY nameChanged)
  Q_PROPERTY(int directory_id READ directory_id WRITE set_directory_id NOTIFY directory_idChanged)
  Q_PROPERTY(QVariant value READ value WRITE set_value NOTIFY valueChanged)

public:
  typedef KeyPtr Ptr;
  typedef QList<Ptr> PtrList;
  friend class KeyPtr;

public:
  Key();
  Key(const Key & other);
  Key(const QJsonObject & json_object); // JSON deserializer
  Key(const QVariantHash & variant_hash);
  Key(const QVariantList & variants);
  Key(const QSqlRecord & record); // SQL deserializer
  Key(const QSqlQuery & query, int offset = 0); // SQL deserializer
  ~Key();

  Key & operator=(const Key & other);

  bool operator==(const Key & other) const;

  // Getter/Setter

  int id() const { return m_id; }
  void set_id(int value);

  const QString & name() const { return m_name; }
  void set_name(const QString & value);

  int directory_id() const { return m_directory_id; }
  void set_directory_id(int value);

  const QVariant & value() const { return m_value; }
  void set_value(const QVariant & value);

  void set_insert_id(int id);
  bool exists_on_database() const { return m_id > 0; } // require NOT NULL

  // JSON Serializer
  QJsonObject to_json(bool only_changed = false) const;

  // Generic Variant Serializer
  QVariantHash to_variant_hash(bool only_changed = false) const;
  QVariantList to_variant_list() const;

  // SQL Serializer
  QVariantHash to_variant_hash_sql(bool only_changed = false, bool duplicate = false) const;
  QVariantList to_variant_list_sql(bool duplicate = false) const;

  // Query for update
  bool is_id_modified() const { return bit_status(Schema::Fields::ID); }
  bool is_name_modified() const { return bit_status(Schema::Fields::NAME); }
  bool is_directory_id_modified() const { return bit_status(Schema::Fields::DIRECTORY_ID); }
  bool is_value_modified() const { return bit_status(Schema::Fields::VALUE); }

  // Field accessor by position
  QVariant field(int position) const;
  void set_field(int position, const QVariant & value);

  bool can_save() const;

  void load_relations();
  void save_relations();

  DirectoryPtr directory();

  bool can_update() const; // To update row
  QVariantHash rowid_kwargs() const;

signals:
  void changed();
  void idChanged();
  void nameChanged();
  void directory_idChanged();
  void valueChanged();

private:
  int m_id;
  QString m_name;
  int m_directory_id;
  QVariant m_value;
  DirectoryPtr m_directory;

};

QDataStream & operator<<(QDataStream & out, const Key & obj);
QDataStream & operator>>(QDataStream & in, Key & obj);
// qRegisterMetaTypeStreamOperators<Key>("Key");

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const Key & obj);
#endif

/**************************************************************************************************/

class KeyPtr
{
public:
  typedef Key Class;

public:
  KeyPtr() : m_ptr() {}
  KeyPtr(const KeyPtr & other) : m_ptr(other.m_ptr) {}
  ~KeyPtr() {
    // Fixme: *this return bool ???
    // Fixme: signal ???
    //// qATInfo() << "--- Delete KeyPtr of" << *m_ptr;
    // qATInfo() << "--- Delete KeyPtr";
    // m_ptr.clear();
  }

  KeyPtr & operator=(const KeyPtr & other) {
    if (this != &other)
      m_ptr = other.m_ptr;
    return *this;
   }

  // QoRowTraits ctor
  KeyPtr(const QSharedPointer<Class> & ptr) : m_ptr(ptr) {}
  KeyPtr(const Class & other) : m_ptr(new Class(other)) {} // Fixme: clone ?
  KeyPtr(const QJsonObject & json_object) : m_ptr(new Class(json_object)) {}
  KeyPtr(const QVariantHash & variant_hash) : m_ptr(new Class(variant_hash)) {}
  KeyPtr(const QVariantList & variants) : m_ptr(new Class(variants)) {}
  KeyPtr(const QSqlRecord & record) : m_ptr(new Class(record)) {}
  KeyPtr(const QSqlQuery & query, int offset = 0) : m_ptr(new Class(query, offset)) {}

  // QSharedPointer API

  QSharedPointer<Class> & ptr() { return m_ptr; }
  QWeakPointer<Class> toWeakRef() const { return m_ptr.toWeakRef(); }

  Class & operator*() const { return *m_ptr; }
  Class * data() { return m_ptr.data(); }
  const Class * data() const { return m_ptr.data(); } // not in the QSharedPointer API

  // row_ptr->method()
  Class * operator->() const { return m_ptr.data(); }

  operator bool() const { return static_cast<bool>(m_ptr); }
  bool isNull() const { return m_ptr.isNull(); }
  bool operator!() const { return m_ptr.isNull(); }

  void clear() { m_ptr.clear(); } // Fixme: danger ???

  bool operator==(const KeyPtr & other) const { return m_ptr == other.m_ptr; }

  // Relations API
  void set_directory(DirectoryPtr & value);

private:
  QSharedPointer<Class> m_ptr;
};

// uint qHash(const KeyPtr & obj) { return static_cast<uint>(obj.data()); }

#ifndef QT_NO_DEBUG_STREAM
QDebug operator<<(QDebug debug, const KeyPtr & obj);
#endif

/**************************************************************************************************/

class KeyCache : public QObject
{
  Q_OBJECT

public:
  typedef Key * t_Key;
  typedef KeyPtr Ptr;
  typedef QList<Ptr> PtrList;

public:
  KeyCache();
  ~KeyCache();

   void add(Ptr & ptr);
   void remove(Ptr & ptr);

    // Fixme: efficiency, QMap has key iterator but not value iterator
   PtrList items() { return m_loaded_instances.values(); }
   const PtrList items() const { return m_loaded_instances.values(); }

public slots:
  void on_changed();

private:
  // QLinkedList<Ptr> m_loaded_instances;
  // QLinkedList<Ptr> m_modified_instances;
  QMap<t_Key, Ptr> m_loaded_instances;
  QMap<t_Key, Ptr> m_modified_instances;
};

/**************************************************************************************************/

class KeyModel : public QAbstractListModel
{
  Q_OBJECT

public:
  typedef KeyPtr Item;
  typedef QList<Item> ItemList;

public:
  KeyModel();
  KeyModel(const ItemList & items);
  ~KeyModel();

  // Fixme: use KeySchema::Fields ???
  enum Roles {
    ID = Qt::UserRole + 1,
    NAME,
    DIRECTORY_ID,
    VALUE
  };
  Q_ENUMS(Roles) // Fixme: ???

  // QAbstractListModel API
  int rowCount(const QModelIndex & parent) const;
  QVariant data(const QModelIndex & index, int role) const;
  QHash<int, QByteArray> roleNames() const;

  void clear_items();
  void set_items(const ItemList & items);

private:
  ItemList m_items;
};

/**************************************************************************************************/

class BlogApplicationSchema : public QoDatabaseSchema
{
public:
  BlogApplicationSchema(QoDatabase & database);
  BlogApplicationSchema(const BlogApplicationSchema & other) = delete;
  ~BlogApplicationSchema();

  BlogApplicationSchema & operator=(const BlogApplicationSchema & other) = delete;

  QoDatabaseTable & directory() { return *m_directory; }
  QoDatabaseTable & key() { return *m_key; }

private:
  template<class T> void register_row(typename T::Ptr & row);

private:
  QoDatabaseTable * m_directory;
  QoDatabaseTable * m_key;
  DirectoryCache m_directory_cache;
  KeyCache m_key_cache;
};

/**************************************************************************************************/
#endif /* __SETTINGS_SCHEMA_H__ */